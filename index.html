<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>FinanceMax Platinum | Financial Systems Edition</title>
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#0f172a">
   
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: { slate: { 850: '#1e293b', 900: '#0f172a', 950: '#020617' } },
                    animation: { 'fade': 'fadeIn 0.2s ease-out', 'up': 'slideUp 0.3s cubic-bezier(0.16, 1, 0.3, 1)', 'spin-once': 'spin 0.5s linear' },
                    keyframes: {
                        fadeIn: { '0%': {opacity:0}, '100%': {opacity:1} },
                        slideUp: { '0%': {transform:'translateY(20px)', opacity:0}, '100%': {transform:'translateY(0)', opacity:1} }
                    }
                }
            }
        }
    </script>
   
    <style>
        body { -webkit-tap-highlight-color: transparent; overscroll-behavior-y: none; }
        .hide-scroll::-webkit-scrollbar { display: none; }
        .glass { background: rgba(255, 255, 255, 0.05); backdrop-filter: blur(12px); border: 1px solid rgba(255,255,255,0.1); }
        .dark .glass { background: rgba(15, 23, 42, 0.6); }
        .loader { width: 20px; height: 20px; border: 2px solid #fff; border-bottom-color: transparent; border-radius: 50%; animation: spin 0.8s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .input-field { width: 100%; padding: 1rem; border-radius: 1rem; background-color: #f8fafc; outline: none; border: 1px solid transparent; transition: all 0.2s; }
        .dark .input-field { background-color: #1e293b; color: white; }
        .input-field:focus { box-shadow: 0 0 0 2px var(--theme-color, #6366f1); background-color: white; }
        .dark .input-field:focus { background-color: #0f172a; }
        .btn-primary { color: white; font-weight: bold; border-radius: 1rem; padding: 1rem; transition: transform 0.1s; width: 100%; }
        .btn-primary:active { transform: scale(0.98); }
        .icon-btn { padding: 0.5rem; border-radius: 9999px; background-color: #f1f5f9; color: #64748b; transition: all; }
        .dark .icon-btn { background-color: #1e293b; color: #94a3b8; }
        .pb-safe { padding-bottom: env(safe-area-inset-bottom); }
        .scroll-x { overflow-x: auto; white-space: nowrap; -webkit-overflow-scrolling: touch; }
        /* Financial state indicators */
        .state-pending { background-color: #fef3c7; color: #92400e; border-color: #fbbf24; }
        .dark .state-pending { background-color: #78350f; color: #fbbf24; }
        .state-approved { background-color: #d1fae5; color: #065f46; border-color: #10b981; }
        .dark .state-approved { background-color: #064e3b; color: #10b981; }
        .state-paid { background-color: #dbeafe; color: #1e40af; border-color: #3b82f6; }
        .dark .state-paid { background-color: #1e3a8a; color: #60a5fa; }
        .state-confirmed { background-color: #dcfce7; color: #166534; border-color: #22c55e; }
        .dark .state-confirmed { background-color: #14532d; color: #4ade80; }
        .state-rejected { background-color: #fee2e2; color: #991b1b; border-color: #ef4444; }
        .dark .state-rejected { background-color: #7f1d1d; color: #f87171; }

        /* Responsive modal helper classes */
        .modal-inner { max-width: calc(100% - 32px); box-sizing: border-box; padding: 1rem; border-radius: 1rem; }
        @media (min-width: 640px) { .modal-inner { max-width: 28rem; padding: 1.5rem; border-radius: 2rem; } }
        .wrap-break { word-break: break-word; overflow-wrap: anywhere; }
        .confirm-buttons { display: flex; gap: 0.75rem; }
        @media (max-width: 639px) { .confirm-buttons { flex-direction: column; } }
        /* Make inputs a bit tighter on small screens */
        .input-field { padding: 0.75rem; }
        @media (min-width: 640px) { .input-field { padding: 1rem; } }
    </style>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/prop-types/prop-types.min.js"></script>
    <script src="https://unpkg.com/recharts@2.10.3/umd/Recharts.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
</head>
<body class="bg-slate-50 text-slate-900 dark:bg-slate-950 dark:text-slate-100 transition-colors duration-300 font-sans h-screen w-screen overflow-hidden">
    <div id="root" class="h-full w-full"></div>
    <script type="text/babel">
        const API_URL = "https://script.google.com/macros/s/AKfycbx0L7jO5pGLNUKWk5k1GebDpWuZLuaG7DDZVGslvNBR2l_gsSoRg02kj0LN1R8j5w/exec";
        const { useState, useEffect, useMemo, useRef } = React;
        const { AreaChart, Area, BarChart, Bar, PieChart, Pie, Cell, ResponsiveContainer, Tooltip, XAxis, Legend } = window.Recharts || {};
        const COLORS = ['#6366f1', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899'];
       
        // FINANCIAL ENGINE CORE UTILS - ENHANCED FOR CENT-PRECISION
        const toCents = (val) => Math.round(parseFloat(val || 0) * 100);
        const fromCents = (val) => Number((val / 100).toFixed(2));
        const formatMoney = (val) => new Intl.NumberFormat('en-IN', { style: 'currency', currency: 'INR', minimumFractionDigits: 2 }).format(val || 0);
        
        // ENHANCED: Smart split calculation with fixed amounts support
        const calculateSmartSplit = (totalCents, participants, fixedAmounts = {}) => {
            // Ensure fixedAmounts respects zero values and uses numeric semantics
            const result = {};
            let fixedTotalCents = 0;

            participants.forEach(id => {
                if (Object.prototype.hasOwnProperty.call(fixedAmounts, id)) {
                    const raw = fixedAmounts[id];
                    const num = Number(raw) || 0;
                    const cents = toCents(num);
                    fixedTotalCents += cents;
                    result[id] = fromCents(cents);
                }
            });

            if (fixedTotalCents > totalCents) {
                return { error: `Manual amounts exceed total by ${formatMoney(fromCents(fixedTotalCents - totalCents))}` };
            }

            const remainingCents = totalCents - fixedTotalCents;
            const remainingParticipants = participants.filter(id => !Object.prototype.hasOwnProperty.call(fixedAmounts, id));

            if (remainingParticipants.length === 0) {
                return result; // all fixed, already validated
            }

            const share = Math.floor(remainingCents / remainingParticipants.length);
            const remainder = remainingCents - (share * remainingParticipants.length);

            remainingParticipants.forEach((id, idx) => {
                const cents = share + (idx === remainingParticipants.length - 1 ? remainder : 0);
                result[id] = fromCents(cents);
            });

            return result;
        };
        
        // FINANCIAL CORRECTNESS: Split amount calculation with remainder absorption
        const calculateEqualSplit = (totalCents, count, payerIndex = 0) => {
            if (count <= 0) return [];
            const shareCents = Math.floor(totalCents / count);
            const remainderCents = totalCents - (shareCents * count);
            const shares = new Array(count).fill(shareCents);
            // FINANCIAL RULE: Remainder always absorbed by payer (index 0 = "Me")
            if (remainderCents > 0 && payerIndex >= 0 && payerIndex < count) {
                shares[payerIndex] += remainderCents;
            }
            return shares.map(cents => fromCents(cents));
        };
        
        // FINANCIAL CORRECTNESS: Validate split sum equals total with cent precision
        const validateSplitSum = (splitAmounts, totalCents) => {
            const sumCents = Object.values(splitAmounts).reduce((sum, val) => 
                sum + toCents(val), 0);
            // Invariant: the split must exactly equal the total in cents (no silent tolerance)
            return sumCents === totalCents;
        };
        
        // FINANCIAL STATE MACHINE: Define allowed transitions
        const ALLOWED_TRANSITIONS = {
            'Pending': ['Approved', 'Rejected', 'Deleted'],
            'Approved': ['Marked as Paid', 'Rejected', 'Deleted'],
            'Marked as Paid': ['Confirmed', 'Approved', 'Deleted'], // 'Approved' = Not Received (goes back to approved)
            'Confirmed': ['Deleted'], // Only deletion with rollback allowed
            'Rejected': ['Deleted'], // Only deletion allowed
        };
        
        // FINANCIAL CORRECTNESS: Validate state transition
        const isValidTransition = (currentState, nextState) => {
            const allowed = ALLOWED_TRANSITIONS[currentState] || [];
            return allowed.includes(nextState);
        };
        
        // FINANCIAL CORRECTNESS: Balance mutation only allowed for Confirmed transactions
        const canMutateBalances = (status) => {
            return status === 'Confirmed';
        };
        
        // FINANCIAL CORRECTNESS: Check if transaction already processed for balances
        const createTransactionHash = (transaction) => {
            return `${transaction.id}_${transaction.status}_${transaction.amount}_${transaction.type}_${transaction.userId}`;
        };
        
        // ENHANCED CATEGORY NORMALIZATION SYSTEM
        const normalizeCategory = (category) => {
            if (!category || typeof category !== 'string') return 'Other';
            
            const normalized = category.toLowerCase().trim();
            
            // Comprehensive category mapping
            const categoryMap = {
                // FOOD & DINING
                'egg': 'Food', 'eggs': 'Food', 'chicken': 'Food', 'mutton': 'Food', 'fish': 'Food',
                'lunch': 'Food', 'dinner': 'Food', 'breakfast': 'Food', 'meal': 'Food', 'food': 'Food',
                'groceries': 'Food', 'vegetables': 'Food', 'fruits': 'Food', 'milk': 'Food',
                'restaurant': 'Food', 'cafe': 'Food', 'coffee': 'Food', 'tea': 'Food',
                'snacks': 'Food', 'chocolate': 'Food', 'biscuit': 'Food', 'cookies': 'Food',
                'pizza': 'Food', 'burger': 'Food', 'sandwich': 'Food', 'noodles': 'Food',
                'rice': 'Food', 'dal': 'Food', 'curry': 'Food', 'sabji': 'Food',
                'sweets': 'Food', 'ice cream': 'Food', 'dessert': 'Food',
                
                // TRANSPORT
                'fuel': 'Transport', 'petrol': 'Transport', 'diesel': 'Transport', 'gas': 'Transport',
                'uber': 'Transport', 'ola': 'Transport', 'rapido': 'Transport', 'taxi': 'Transport',
                'auto': 'Transport', 'rickshaw': 'Transport', 'bus': 'Transport', 'train': 'Transport',
                'metro': 'Transport', 'flight': 'Transport', 'travel': 'Transport',
                'parking': 'Transport', 'toll': 'Transport', 'maintenance': 'Transport',
                
                // HOUSING & UTILITIES
                'rent': 'Housing', 'emi': 'Housing', 'mortgage': 'Housing',
                'electricity': 'Utilities', 'water': 'Utilities', 'gas bill': 'Utilities',
                'internet': 'Utilities', 'wifi': 'Utilities', 'broadband': 'Utilities',
                'mobile': 'Utilities', 'phone': 'Utilities', 'recharge': 'Utilities',
                
                // ENTERTAINMENT
                'movie': 'Entertainment', 'netflix': 'Entertainment', 'prime': 'Entertainment',
                'hotstar': 'Entertainment', 'youtube': 'Entertainment', 'spotify': 'Entertainment',
                'concert': 'Entertainment', 'game': 'Entertainment', 'gaming': 'Entertainment',
                'outing': 'Entertainment', 'party': 'Entertainment', 'alcohol': 'Entertainment',
                'drinks': 'Entertainment', 'bar': 'Entertainment',
                
                // SHOPPING
                'shopping': 'Shopping', 'clothes': 'Shopping', 'shoes': 'Shopping',
                'electronics': 'Shopping', 'phone': 'Shopping', 'laptop': 'Shopping',
                'accessories': 'Shopping', 'watch': 'Shopping', 'jewelry': 'Shopping',
                'cosmetics': 'Shopping', 'makeup': 'Shopping', 'skincare': 'Shopping',
                
                // HEALTHCARE
                'medical': 'Healthcare', 'hospital': 'Healthcare', 'doctor': 'Healthcare',
                'medicine': 'Healthcare', 'pharmacy': 'Healthcare', 'test': 'Healthcare',
                'insurance': 'Healthcare', 'gym': 'Healthcare', 'fitness': 'Healthcare',
                'yoga': 'Healthcare',
                
                // EDUCATION
                'education': 'Education', 'books': 'Education', 'course': 'Education',
                'tuition': 'Education', 'school': 'Education', 'college': 'Education',
                'stationery': 'Education',
                
                // PERSONAL CARE
                'salon': 'Personal Care', 'haircut': 'Personal Care', 'spa': 'Personal Care',
                'massage': 'Personal Care', 'grooming': 'Personal Care',
                
                // GIFTS & DONATIONS
                'gift': 'Gifts', 'donation': 'Gifts', 'charity': 'Gifts',
                
                // INVESTMENTS
                'investment': 'Investment', 'stocks': 'Investment', 'mutual fund': 'Investment',
                'sip': 'Investment', 'fd': 'Investment', 'gold': 'Investment',
                
                // INCOME
                'salary': 'Income', 'freelance': 'Income', 'business': 'Income',
                'refund': 'Income', 'interest': 'Income', 'dividend': 'Income',
                
                // DEFAULT CATEGORIES
                'general': 'General', 'other': 'Other', 'misc': 'Other', 'miscellaneous': 'Other'
            };
            
            // Check exact matches first
            if (categoryMap[normalized]) {
                return categoryMap[normalized];
            }
            
            // Check for partial matches
            for (const [key, value] of Object.entries(categoryMap)) {
                if (normalized.includes(key) || key.includes(normalized)) {
                    return value;
                }
            }
            
            // If category contains food-related words
            const foodKeywords = ['egg', 'chicken', 'mutton', 'fish', 'rice', 'dal', 'curry', 'vegetable', 'fruit', 'milk'];
            if (foodKeywords.some(keyword => normalized.includes(keyword))) {
                return 'Food';
            }
            
            // If category contains transport-related words
            const transportKeywords = ['fuel', 'petrol', 'diesel', 'uber', 'ola', 'taxi', 'bus', 'train'];
            if (transportKeywords.some(keyword => normalized.includes(keyword))) {
                return 'Transport';
            }
            
            return category.charAt(0).toUpperCase() + category.slice(1); // Capitalize first letter
        };
        
        const compressImage = (file) => new Promise((resolve) => {
            const reader = new FileReader(); reader.readAsDataURL(file);
            reader.onload = (e) => { const img = new Image(); img.src = e.target.result; img.onload = () => { const canvas = document.createElement('canvas'); const scale = 600 / img.width; canvas.width = 600; canvas.height = img.height * scale; const ctx = canvas.getContext('2d'); ctx.drawImage(img, 0, 0, canvas.width, canvas.height); resolve(canvas.toDataURL('image/jpeg', 0.6)); }; };
        });
        // A palette of theme templates (16 options). Each has a primary color and Tailwind class hints.
        const THEMES = {
            indigo:  { bg: '#6366f1', class: 'bg-indigo-600',  text: 'text-indigo-600',  border: 'border-indigo-600' },
            emerald: { bg: '#10b981', class: 'bg-emerald-600', text: 'text-emerald-600', border: 'border-emerald-600' },
            rose:    { bg: '#e11d48', class: 'bg-rose-600',    text: 'text-rose-600',    border: 'border-rose-600' },
            amber:   { bg: '#f59e0b', class: 'bg-amber-600',   text: 'text-amber-600',   border: 'border-amber-600' },
            cyan:    { bg: '#06b6d4', class: 'bg-cyan-600',    text: 'text-cyan-600',    border: 'border-cyan-600' },
            teal:    { bg: '#14b8a6', class: 'bg-teal-600',    text: 'text-teal-600',    border: 'border-teal-600' },
            violet:  { bg: '#8b5cf6', class: 'bg-violet-600',  text: 'text-violet-600',  border: 'border-violet-600' },
            fuchsia: { bg: '#d946ef', class: 'bg-fuchsia-600', text: 'text-fuchsia-600', border: 'border-fuchsia-600' },
            pink:    { bg: '#ec4899', class: 'bg-pink-600',    text: 'text-pink-600',    border: 'border-pink-600' },
            lime:    { bg: '#84cc16', class: 'bg-lime-600',    text: 'text-lime-600',    border: 'border-lime-600' },
            yellow:  { bg: '#f59e0b', class: 'bg-yellow-500',  text: 'text-yellow-500',  border: 'border-yellow-500' },
            orange:  { bg: '#fb923c', class: 'bg-orange-500',  text: 'text-orange-500',  border: 'border-orange-500' },
            blue:    { bg: '#3b82f6', class: 'bg-blue-600',    text: 'text-blue-600',    border: 'border-blue-600' },
            gray:    { bg: '#6b7280', class: 'bg-gray-600',    text: 'text-gray-600',    border: 'border-gray-600' },
            slate:   { bg: '#0f172a', class: 'bg-slate-900',   text: 'text-slate-900',   border: 'border-slate-900' },
            sky:     { bg: '#0ea5e9', class: 'bg-sky-600',     text: 'text-sky-600',     border: 'border-sky-600' }
        };
        function Avatar({ imageId, name, size="md", theme }) {
            const [err, setErr] = useState(false);
            const dims = size==='lg'?'w-24 h-24 text-4xl':size==='sm'?'w-8 h-8 text-xs':'w-12 h-12 text-base';
            const url = imageId ? `https://drive.google.com/thumbnail?id=${imageId}&sz=w400` : null;
            const borderColor = (THEMES[theme] && THEMES[theme].bg) || '#cbd5e1';
            return <div className={`shrink-0 rounded-full flex items-center justify-center overflow-hidden ${dims} ${(!url || err) && 'bg-slate-100 dark:bg-slate-800'}`} style={{color: THEMES[theme] ? THEMES[theme].bg : undefined, borderColor: borderColor, borderStyle: 'solid', borderWidth: '1px'}}>{url && !err ? <img loading="lazy" src={url} className="w-full h-full object-cover" onError={()=>setErr(true)}/> : <span className="font-bold">{name?name[0].toUpperCase():'?'}</span>}</div>;
        }
        function ConfirmDialog({ isOpen, title, msg, onConfirm, onCancel, type='neutral', theme, single=false, confirmLabel='Confirm' }) {
            if(!isOpen) return null;
            const isDanger = type === 'danger';
            const iconBgStyle = isDanger ? { backgroundColor: '#fee2e2', color: '#ef4444' } : { backgroundColor: `${THEMES[theme].bg}20`, color: THEMES[theme].bg };
            const confirmBtnClass = isDanger ? 'bg-red-500 shadow-red-500/30' : `${THEMES[theme].class} shadow-lg`;
            return (
                <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 animate-fade">
                    <div className="absolute inset-0 bg-slate-900/60 backdrop-blur-md" onClick={onCancel}></div>
                    <div className="relative bg-white dark:bg-slate-900 w-full max-w-xs modal-inner shadow-2xl border border-slate-100 dark:border-slate-800 animate-up">
                        <div className="w-16 h-16 rounded-full flex items-center justify-center mx-auto mb-5" style={iconBgStyle}>
                            <i data-lucide={isDanger ? 'alert-triangle' : 'help-circle'} className="w-8 h-8"></i>
                        </div>
                        <h3 className="font-bold text-xl dark:text-white mb-2 text-center">{title}</h3>
                        <p className="text-slate-500 dark:text-slate-400 text-sm mb-8 text-center leading-relaxed wrap-break">{msg}</p>
                        <div className="confirm-buttons stack-on-mobile">
                            {!single && <button onClick={onCancel} className="flex-1 py-3.5 rounded-2xl bg-slate-100 dark:bg-slate-800 text-slate-600 dark:text-slate-300 font-bold text-sm hover:bg-slate-200 dark:hover:bg-slate-700 transition-colors">Cancel</button>}
                            <button onClick={onConfirm} className={`flex-1 py-3.5 rounded-2xl font-bold text-sm text-white shadow-xl active:scale-95 transition-transform ${confirmBtnClass}`}>{confirmLabel}</button>
                        </div>
                    </div>
                </div>
            );
        }
        
        // FINANCIAL CORRECTNESS: Transaction State Component
        function TransactionStateBadge({ status, theme, iconOnly=false, small=false }) {
            // Visual mapping (non-destructive)
            const stateConfig = {
                'Pending': { label: 'Pending', icon: 'clock', bg: 'bg-amber-100', fg: 'text-amber-600' },
                'Approved': { label: 'Approved', icon: 'check-circle', bg: 'bg-emerald-50', fg: 'text-emerald-600' },
                'Marked as Paid': { label: 'Paid', icon: 'check-circle', bg: 'bg-emerald-50', fg: 'text-emerald-600' },
                'Confirmed': { label: 'Confirmed', icon: 'check-circle', bg: 'bg-emerald-50', fg: 'text-emerald-600' },
                'Rejected': { label: 'Rejected', icon: 'x-circle', bg: 'bg-red-50', fg: 'text-red-600' },
                'Not Received': { label: 'Not Received', icon: 'alert-circle', bg: 'bg-red-50', fg: 'text-red-600' }
            };

            const config = stateConfig[status] || { label: status, icon: 'help-circle', bg: 'bg-slate-100', fg: 'text-slate-600' };

            if (iconOnly) {
                // Small variant: minimal, no background (keeps layout compact)
                if (small) {
                    return (
                        <span title={config.label} className={`status-icon-small ${config.fg}`} role="img" aria-label={config.label}>
                            <i data-lucide={config.icon} className="w-3 h-3"></i>
                        </span>
                    );
                }

                // Icon-only compact badge: subtle background and consistent size
                return (
                    <span title={config.label} className={`status-icon-inline ${config.bg} ${config.fg}`} role="img" aria-label={config.label}>
                        <i data-lucide={config.icon} className="w-4 h-4"></i>
                    </span>
                );
            }

            return (
                <span className={`inline-flex items-center gap-1 px-2 py-1 rounded-full text-[10px] font-bold uppercase ${config.bg} ${config.fg}`}>
                    <i data-lucide={config.icon} className="w-3 h-3"></i>
                    {config.label}
                </span>
            );
               
        }
        
        function Dashboard({ user, onLogout }) {
            const [data, setData] = useState({ transactions: [], people: [] });
            const [view, setView] = useState('home');
            const [modal, setModal] = useState(null);
            const [editItem, setEditItem] = useState(null);
            const [selectedFriend, setSelectedFriend] = useState(null);
            const [rejectedItems, setRejectedItems] = useState([]);
            const [dialog, setDialog] = useState({ isOpen: false });
            const [darkMode, setDarkMode] = useState(true);
            const [currentUser, setCurrentUser] = useState(user);
            const [loading, setLoading] = useState(false);
            const [refreshing, setRefreshing] = useState(false);
            const [filterDays, setFilterDays] = useState('TODAY');
            const [customN, setCustomN] = useState('');
            const [searchTerm, setSearchTerm] = useState('');
            const [activeGraph, setActiveGraph] = useState('trend');
            const [dateFrom, setDateFrom] = useState(null);
            const [dateTo, setDateTo] = useState(null);
            const [filterType, setFilterType] = useState('ALL'); // ALL, INCOMING, OUTGOING, REPAYMENT, LENT, BORROWED
            const [theme, setTheme] = useState(localStorage.getItem('fm_theme') || 'indigo');
            const [accentColor, setAccentColor] = useState(localStorage.getItem('fm_accent') || THEMES[localStorage.getItem('fm_theme') || 'indigo'].bg);
            const [budget, setBudget] = useState(localStorage.getItem('fm_budget') || '0');
            const [isCalendarMode, setIsCalendarMode] = useState(false);
            const [selectedDate, setSelectedDate] = useState(new Date().toISOString().split('T')[0]);
            const [calMonth, setCalMonth] = useState(new Date().getMonth());
            const [calYear, setCalYear] = useState(new Date().getFullYear());
            
            useEffect(() => {
                if(darkMode) document.documentElement.classList.add('dark'); else document.documentElement.classList.remove('dark');
                // Apply accent color CSS variable and persist theme/accent
                document.documentElement.style.setProperty('--theme-color', accentColor || THEMES[theme].bg);
                localStorage.setItem('fm_theme', theme);
                localStorage.setItem('fm_accent', accentColor);

                const cachedData = localStorage.getItem('fm_data');
                if(cachedData) setData(JSON.parse(cachedData));
                fetchData();
            }, [darkMode, theme, accentColor]);
            
            useEffect(() => { 
                setTimeout(() => lucide.createIcons(), 200); 
            }, [view, modal, data, rejectedItems, dialog, filterDays, theme, activeGraph, selectedFriend, isCalendarMode, calMonth, refreshing]);
            
            const fetchData = async (params = null) => {
                setLoading(true);
                try {
                    // Use explicit params if provided, otherwise fall back to lastFetchParams (if any)
                    const effectiveParams = params || lastFetchParams || {};
                    // Keep lastFetchParams in sync for refreshes
                    if (params) setLastFetchParams(params);

                    const q = new URLSearchParams({ action: 'getData', userId: currentUser.id, ...effectiveParams }).toString();
                    const res = await fetch(`${API_URL}?${q}`);
                    const json = await res.json();
                    if(json.success) {
                        const newData = { transactions: json.transactions, people: json.people };
                        setData(newData);
                        localStorage.setItem('fm_data', JSON.stringify(newData));
                        if(json.userProfile) setCurrentUser(json.userProfile);
                        const rejected = json.transactions.filter(t => t.userId === currentUser.id && t.status === 'Rejected');
                        if (rejected.length > 0) setRejectedItems(rejected);
                    } else {
                        console.warn('fetchData returned success=false', json);
                    }
                } catch(e) {
                    console.error('fetchData error', e);
                }
                setLoading(false);
            };

            // Periodic polling: refresh server data (people/transactions) every 30s while the page is visible
            useEffect(() => {
                let intervalId = null;
                const poll = async () => {
                    if (document.hidden) return;
                    try { await fetchData(lastFetchParams); } catch(e) { /* ignore */ }
                };
                // Kick off a poll shortly after mount
                const timeout = setTimeout(poll, 1500);
                intervalId = setInterval(poll, 30000);
                const onVis = () => { if (!document.hidden) poll(); };
                document.addEventListener('visibilitychange', onVis);
                return () => { clearTimeout(timeout); clearInterval(intervalId); document.removeEventListener('visibilitychange', onVis); };
            }, [lastFetchParams]);

            // Centralized mutation helper: supports skipFetch to avoid blocking re-fetch and UI flicker
            const mutate = async (body, { skipFetch = false } = {}) => {
                try {
                    const res = await fetch(API_URL, { method: 'POST', body: JSON.stringify(body) });
                    const json = await res.json();
                    if (!skipFetch) {
                        // Refresh latest data if caller wants canonical state
                        await fetchData(lastFetchParams);
                    }
                    return json;
                } catch (e) {
                    console.error('Mutation error', e);
                    throw e;
                }
            };

            // Optimistic mutate helper: apply optimistic UI immediately, then call server; rollback on error
            const optimisticMutate = async (body, applyOptimistic, rollback) => {
                try {
                    applyOptimistic();
                    const json = await mutate(body, { skipFetch: true });
                    if (json && json.success === false) {
                        rollback && rollback();
                        alert(json.error || 'Error');
                    }
                    return json;
                } catch (e) {
                    rollback && rollback();
                    alert('Error: ' + (e?.message || e));
                    throw e;
                }
            };
            
            const handleRefresh = () => {
                setRefreshing(true);
                setTimeout(() => window.location.reload(), 300);
            };
            
            const confirmAction = (title, msg, onConfirm, type='neutral') => setDialog({ isOpen: true, title, msg, onConfirm: () => { onConfirm(); setDialog({ isOpen: false }); }, onCancel: () => setDialog({ isOpen: false }), type });

            // Filter state & helpers
            const [lastFetchParams, setLastFetchParams] = useState(null);
            const applyFilters = (overrides = {}) => {
                // compute new filter values (allow overrides)
                const nextFilterDays = overrides.filterDays !== undefined ? overrides.filterDays : filterDays;
                const nextDateFrom = overrides.dateFrom !== undefined ? overrides.dateFrom : dateFrom;
                const nextDateTo = overrides.dateTo !== undefined ? overrides.dateTo : dateTo;
                const nextFilterType = overrides.filterType !== undefined ? overrides.filterType : filterType;
                const nextSearch = overrides.searchTerm !== undefined ? overrides.searchTerm : searchTerm;

                // Build params for backend
                const params = {};
                if (nextFilterDays === 'TODAY') {
                    const now = new Date(); now.setHours(0,0,0,0); const s = now.toISOString().split('T')[0]; params.dateFrom = s; params.dateTo = s;
                } else if (nextFilterDays === 'YESTERDAY') {
                    const now = new Date(); now.setHours(0,0,0,0); const y = new Date(now); y.setDate(y.getDate()-1); const s = y.toISOString().split('T')[0]; params.dateFrom = s; params.dateTo = s;
                } else if (nextFilterDays === '7' || nextFilterDays === '30') {
                    params.days = nextFilterDays;
                } else if (nextFilterDays === 'RANGE') {
                    if (nextDateFrom) params.dateFrom = nextDateFrom;
                    if (nextDateTo) params.dateTo = nextDateTo;
                } // ALL -> no date params

                if (nextFilterType && nextFilterType !== 'ALL') params.filterType = nextFilterType;
                if (nextSearch) params.search = nextSearch;

                // update local UI state and persist last params
                setFilterDays(nextFilterDays); setDateFrom(nextDateFrom); setDateTo(nextDateTo); setFilterType(nextFilterType); setSearchTerm(nextSearch);
                setLastFetchParams(params);
                // fetch with params (backend-aware)
                fetchData(params);
            };

            const clearFilters = () => {
                applyFilters({ filterDays: '7', filterType: 'ALL', dateFrom: null, dateTo: null, searchTerm: '' });
            };

            // FINANCIAL CORRECTNESS: Enhanced approval with state transition validation
            const handleApproval = (t, status) => {
                // Validate state transition
                if (!isValidTransition(t.status, status)) {
                    alert(`Invalid state transition: ${t.status} â†’ ${status}`);
                    return;
                }
                
                let title = 'Update Transaction?';
                if (status === 'Approved') title = 'Approve Transaction?';
                else if (status === 'Rejected') title = 'Reject Transaction?';
                else if (status === 'Marked as Paid') title = 'Mark as Paid?';
                else if (status === 'Confirmed') title = 'Confirm Transaction?';
                
                confirmAction(
                    title,
                    `This will update your financial records.`,
                    async () => {
                        const prevStatus = t.status;
                        await optimisticMutate({ action: 'handleApproval', transactionId: t.id, status: status, previousStatus: prevStatus },
                            () => {
                                // optimistic apply
                                setData(prev => ({ ...prev, transactions: prev.transactions.map(tr => tr.id === t.id ? { ...tr, status } : tr) }));
                            },
                            () => {
                                // rollback
                                setData(prev => ({ ...prev, transactions: prev.transactions.map(tr => tr.id === t.id ? { ...tr, status: prevStatus } : tr) }));
                            }
                        );
                    },
                    status === 'Rejected' ? 'danger' : 'neutral'
                );
            };
            
            // FINANCIAL CORRECTNESS: Enhanced payment confirmation flow
            const handlePaymentConfirmation = (t, status) => {
                if (t.status !== 'Marked as Paid' && status === 'Confirmed') {
                    alert('Transaction must be marked as paid before confirming receipt');
                    return;
                }
                
                // Map "Not Received" to "Approved" (goes back to approved state)
                const actualStatus = status === 'Not Received' ? 'Approved' : status;
                
                if (!isValidTransition(t.status, actualStatus)) {
                    alert(`Invalid state transition: ${t.status} â†’ ${actualStatus}`);
                    return;
                }
                
                let title = 'Confirm Receipt?';
                let message = 'This will update your balances and mark the payment as received.';
                
                if (status === 'Not Received') {
                    title = 'Payment Not Received?';
                    message = 'This will return the transaction to "Approved" status. The other person will need to mark it as paid again.';
                }
                
                confirmAction(
                    title,
                    message,
                    async () => {
                        const prevStatus = t.status;
                        // Use handleApproval backend action for all status updates
                        await optimisticMutate({ action: 'handleApproval', transactionId: t.id, status: actualStatus, previousStatus: prevStatus },
                            () => {
                                setData(prev => ({ ...prev, transactions: prev.transactions.map(tr => tr.id === t.id ? { ...tr, status: actualStatus } : tr) }));
                            },
                            () => {
                                setData(prev => ({ ...prev, transactions: prev.transactions.map(tr => tr.id === t.id ? { ...tr, status: prevStatus } : tr) }));
                            }
                        );
                    },
                    status === 'Not Received' ? 'danger' : 'neutral'
                );
            };
            
            // FINANCIAL CORRECTNESS: Enhanced friend removal with net balance check
            const removePerson = (p) => {
                // Calculate net balance for this person
                let net = 0;
                data.transactions.forEach(t => {
                    if (t.status === 'Rejected' || t.status === 'Deleted') return;
                    
                    const isMine = t.userId === currentUser.id;
                    if (!isMine && t.status === 'Pending') return;
                    
                    const amt = toCents(t.amount);
                    if (isMine && t.relatedPerson === p.id) {
                        if(t.type === 'lent') net += amt;
                        if(t.type === 'repayment_in') net -= amt;
                        if(t.type === 'borrowed') net -= amt;
                        if(t.type === 'repayment_out') net += amt;
                    }
                });
                
                if (Math.abs(net) > 0) {
                    alert(`Cannot remove friend with outstanding balance: ${formatMoney(fromCents(Math.abs(net)))}`);
                    return;
                }
                
                confirmAction('Remove Friend?', `Ensure balance is 0. This cannot be undone.`, async () => {
                    setLoading(true);
                    try {
                        const json = await mutate({ action: 'deletePerson', userId: currentUser.id, personId: p.id });
                        if(!json.success) alert(json.error || 'Error');
                    } catch(e) { alert("Error"); }
                    setLoading(false);
                }, 'danger');
            };
            
            const exportCSV = () => {
                const headers = ["Date", "Type", "Amount", "Category", "Description", "Friend", "Status", "State"];
                const rows = data.transactions.map(t => [t.date.split('T')[0], t.type, t.amount, t.category, `"${t.description}"`, t.relatedPerson || "-", t.status, t.state || '']);
                const csvContent = "data:text/csv;charset=utf-8," + headers.join(",") + "\n" + rows.map(e => e.join(",")).join("\n");
                const link = document.createElement("a");
                link.setAttribute("href", encodeURI(csvContent));
                link.setAttribute("download", "financemax_data.csv");
                document.body.appendChild(link);
                link.click();
            };
            
            // FIXED: RE-ENGINEERED FINANCIAL ENGINE WITH STRICT INVARIANTS
            const stats = useMemo(() => {
                let cashBal=0, onlineBal=0, asset=0, liability=0, income=0, expense=0;
                const graph = {}; 
                const catMap = {};
                
                data.transactions.forEach(t => {
                    // FINANCIAL RULE: Rejected/Deleted transactions are financially invisible
                    if (t.status === 'Rejected' || t.status === 'Deleted') return;
                    
                    const isMine = t.userId === currentUser.id;
                    
                    // FINANCIAL RULE: No balance mutation before Confirmed status
                    const canAffectBalances = canMutateBalances(t.status);
                    
                    const amt = toCents(t.amount);
                    const d = t.date.split('T')[0];
                    if(!graph[d]) graph[d] = {date:d, val:0};
                    
                    if (isMine) {
                        // FINANCIAL RULE: Only confirmed movements affect available balances
                        if (canAffectBalances) {
                            if (t.type === 'income') {
                                t.paymentMode === 'Cash' ? cashBal += amt : onlineBal += amt;
                                income += amt; 
                                graph[d].val += amt;
                            }
                            else if (t.type === 'expense') {
                                t.paymentMode === 'Cash' ? cashBal -= amt : onlineBal -= amt;
                                expense += amt; 
                                graph[d].val -= amt; 
                                const normalizedCategory = normalizeCategory(t.category);
                                catMap[normalizedCategory] = (catMap[normalizedCategory]||0)+amt;
                            }
                            else if (t.type === 'lent') {
                                t.paymentMode === 'Cash' ? cashBal -= amt : onlineBal -= amt;
                                asset += amt; 
                                graph[d].val -= amt;
                            }
                            else if (t.type === 'borrowed') {
                                t.paymentMode === 'Cash' ? cashBal += amt : onlineBal += amt;
                                liability += amt; 
                                graph[d].val += amt;
                            }
                            else if (t.type === 'repayment_in') {
                                t.paymentMode === 'Cash' ? cashBal += amt : onlineBal += amt;
                                asset -= amt; 
                                graph[d].val += amt;
                            }
                            else if (t.type === 'repayment_out') {
                                t.paymentMode === 'Cash' ? cashBal -= amt : onlineBal -= amt;
                                liability -= amt; 
                                graph[d].val -= amt;
                            }
                        }
                    } else {
                        // Synced transactions initiated by others
                        // FINANCIAL RULE: Only affect friend net if confirmed
                        if (canAffectBalances) {
                            if (t.type === 'lent') liability += amt;
                            else if (t.type === 'borrowed') asset += amt;
                            else if (t.type === 'repayment_in') liability -= amt;
                            else if (t.type === 'repayment_out') asset -= amt;
                        }
                    }
                });
                
                asset = Math.max(0, asset);
                liability = Math.max(0, liability);
                const pieData = Object.keys(catMap).map((k,i) => ({ name: k, value: fromCents(catMap[k]), color: COLORS[i % COLORS.length] }));
                const barData = [{ name: 'In', value: fromCents(income) }, { name: 'Out', value: fromCents(expense) }, { name: 'Lent', value: fromCents(asset) }, { name: 'Debt', value: fromCents(liability) }];
                
                let insight = "âœ… Financial health looks stable.";
                if(expense > income && income > 0) insight = "âš ï¸ Expenses exceed income.";
                if(liability > asset) insight = "ðŸ’¡ Tip: Debt > Assets.";
                
                // FIXED: Enhanced friend net calculation with proper direction
                const peopleStats = data.people.map(p => {
                    let net = 0;
                    data.transactions.forEach(t => {
                        // FINANCIAL RULE: Rejected/Deleted transactions don't affect net
                        if (t.status === 'Rejected' || t.status === 'Deleted') return;
                        
                        const isMine = t.userId === currentUser.id;
                        // FINANCIAL RULE: Pending sync transactions don't affect net
                        if (!isMine && t.status === 'Pending') return;
                        
                        const friendEmail = p.email ? p.email.toLowerCase() : "";
                        const creatorEmail = t.creatorEmail ? t.creatorEmail.toLowerCase() : "";
                        const amt = toCents(t.amount);
                        
                        if (isMine && t.relatedPerson === p.id) {
                            // FINANCIAL RULE: Only confirmed transactions affect net
                            if (canMutateBalances(t.status)) {
                                // I lent money to friend (they owe me) = POSITIVE
                                if(t.type === 'lent') net += amt;
                                // Friend repaid me (they gave back) = NEGATIVE
                                if(t.type === 'repayment_in') net -= amt;
                                // I borrowed from friend (I owe them) = NEGATIVE
                                if(t.type === 'borrowed') net -= amt;
                                // I repaid friend (I gave back) = POSITIVE
                                if(t.type === 'repayment_out') net += amt;
                            }
                        }
                        if (!isMine && creatorEmail === friendEmail) {
                            // FINANCIAL RULE: Only confirmed sync transactions affect net
                            if (canMutateBalances(t.status)) {
                                // Friend lent me money (they say I owe them) = NEGATIVE
                                if(t.type === 'lent') net -= amt;
                                // Friend says I borrowed from them (they owe me) = POSITIVE
                                if(t.type === 'borrowed') net += amt;
                                // Friend repaid me (they gave back) = POSITIVE
                                if(t.type === 'repayment_in') net += amt;
                                // Friend says I repaid them (I gave back) = NEGATIVE
                                if(t.type === 'repayment_out') net -= amt;
                            }
                        }
                    });
                    return { ...p, net: fromCents(net) };
                });
                
                return {
                    cashBal: fromCents(cashBal),
                    onlineBal: fromCents(onlineBal),
                    total: fromCents(cashBal+onlineBal),
                    rented: fromCents(asset),
                    taken: fromCents(liability),
                    insight,
                    pieData,
                    barData,
                    graphArea: Object.values(graph).sort((a,b)=>new Date(a.date)-new Date(b.date)).map(g=>({...g, val:fromCents(g.val)})),
                    peopleStats
                };
            }, [data.transactions, currentUser.id]);
            
            // FINANCIAL CORRECTNESS: Enhanced requests with multi-stage flow
            // Logic: 
            // - Pending/Approved: Show to recipient (person who needs to approve/pay)
            // - Marked as Paid: Show to creator (person who gave money and needs to confirm receipt)
            const requests = data.transactions.filter(t => {
                const isMine = t.userId === currentUser.id;
                const isSynced = !isMine;
                
                // Show to recipient: transactions created by others that need approval/payment
                if (isSynced && (t.status === 'Pending' || t.status === 'Approved')) {
                    return true;
                }
                
                // Show to creator: transactions I created that are marked as paid (I need to confirm receipt)
                if (isMine && t.status === 'Marked as Paid') {
                    return true;
                }
                
                return false;
            });
            
            // TASK 1: Day-based Date Filter Logic (Before Aggregation)
            const filterTransactions = (list) => {
                const now = new Date(); now.setHours(0,0,0,0);
                return list.filter(t => {
                    // Exclude soft-deleted / rejected
                    if(t.status === 'Rejected' || t.status === 'Deleted') return false;

                    // Text search
                    const normalizedCategory = normalizeCategory(t.category);
                    const cat = (t.category || '').toString();
                    const desc = (t.description || '').toString();
                    const matchSearch = normalizedCategory.toLowerCase().includes(searchTerm.toLowerCase()) || 
                                       cat.toLowerCase().includes(searchTerm.toLowerCase()) || 
                                       desc.toLowerCase().includes(searchTerm.toLowerCase()) || 
                                       (t.amount !== undefined && t.amount !== null && t.amount.toString().includes(searchTerm));
                    if(!matchSearch) return false;

                    // Date normalization
                    const txDate = new Date(t.date); txDate.setHours(0,0,0,0);

                    // Calendar mode: exact date
                    if (isCalendarMode) {
                        if (txDate.toISOString().split('T')[0] !== selectedDate) return false;
                    } else {
                        // Date-range / preset filters
                        if (filterDays === 'ALL') {
                            // no date restriction
                        } else if (filterDays === 'TODAY') {
                            if (txDate.getTime() !== now.getTime()) return false;
                        } else if (filterDays === 'YESTERDAY') {
                            const yesterday = new Date(now); yesterday.setDate(yesterday.getDate() - 1);
                            if (txDate.getTime() !== yesterday.getTime()) return false;
                        } else if (filterDays === 'RANGE') {
                            // If both dates present, treat as inclusive range
                            if (dateFrom && dateTo) {
                                const from = new Date(dateFrom); from.setHours(0,0,0,0);
                                const to = new Date(dateTo); to.setHours(0,0,0,0);
                                if (txDate < from || txDate > to) return false;
                            } else if (dateFrom) {
                                const from = new Date(dateFrom); from.setHours(0,0,0,0);
                                if (txDate.getTime() !== from.getTime()) return false;
                            } // else no date constraints
                        } else {
                            // Numeric day presets and custom N (7, 30, CUSTOM)
                            let dLimit = 0;
                            if (filterDays === '7') dLimit = 7;
                            else if (filterDays === '30') dLimit = 30;
                            else if (filterDays === 'CUSTOM') {
                                const n = parseInt(customN);
                                dLimit = (isNaN(n) || n < 0) ? 0 : n;
                            }

                            if (dLimit > 0) {
                                const cutoff = new Date(now);
                                cutoff.setDate(cutoff.getDate() - dLimit);
                                if (txDate < cutoff) return false;
                            }
                        }
                    }

                    // Transaction type / flow filters
                    if (filterType && filterType !== 'ALL') {
                        const isMine = t.userId === currentUser.id;
                        let effectiveType = t.type;
                        if (!isMine) {
                            // Mirror types for synced transactions so semantics are consistent for the viewer
                            if (t.type === 'lent') effectiveType = 'borrowed';
                            else if (t.type === 'borrowed') effectiveType = 'lent';
                            else if (t.type === 'repayment_in') effectiveType = 'repayment_out';
                            else if (t.type === 'repayment_out') effectiveType = 'repayment_in';
                        }

                        const incomingTypes = ['income', 'borrowed', 'repayment_in'];
                        const outgoingTypes = ['expense', 'lent', 'repayment_out'];
                        const repaymentTypes = ['repayment_in', 'repayment_out'];

                        if (filterType === 'INCOMING' && !incomingTypes.includes(effectiveType)) return false;
                        if (filterType === 'OUTGOING' && !outgoingTypes.includes(effectiveType)) return false;
                        if (filterType === 'REPAYMENT' && !repaymentTypes.includes(effectiveType)) return false;
                    }

                    return true;
                });
            };
            
            const filteredHistory = filterTransactions(data.transactions);
            
            // TASK 2: Aggregating Summary Cards from Filtered Dataset
            const historySummary = useMemo(() => {
                let inc = 0, out = 0;
                filteredHistory.forEach(t => {
                    // FINANCIAL RULE: Only confirmed transactions affect summary
                    if (!canMutateBalances(t.status)) return;
                    
                    const isMine = t.userId === currentUser.id;
                    const amt = toCents(t.amount);
                    
                    if (isMine) {
                        if (['income', 'borrowed', 'repayment_in'].includes(t.type)) inc += amt;
                        else if (['expense', 'lent', 'repayment_out'].includes(t.type)) out += amt;
                    } else {
                        if (['borrowed', 'repayment_in'].includes(t.type)) inc += amt;
                        else if (['lent', 'repayment_out'].includes(t.type)) out += amt;
                    }
                });
                return { in: fromCents(inc), out: fromCents(out) };
            }, [filteredHistory, currentUser.id]);
            
            const calendarGrid = useMemo(() => {
                const firstDay = new Date(calYear, calMonth, 1).getDay();
                const daysInMonth = new Date(calYear, calMonth + 1, 0).getDate();
                const grid = [];
                for(let i=0; i<firstDay; i++) grid.push(null);
                for(let i=1; i<=daysInMonth; i++) {
                    const dateStr = new Date(calYear, calMonth, i).toISOString().split('T')[0];
                    const hasInc = data.transactions.some(t => t.date.startsWith(dateStr) && (t.type==='income'||t.type==='repayment_in'||t.type==='borrowed') && canMutateBalances(t.status));
                    const hasExp = data.transactions.some(t => t.date.startsWith(dateStr) && (t.type==='expense'||t.type==='lent'||t.type==='repayment_out') && canMutateBalances(t.status));
                    grid.push({ day: i, date: dateStr, hasInc, hasExp });
                }
                return grid;
            }, [calMonth, calYear, data.transactions]);
            
            const changeMonth = (dir) => { let m = calMonth + dir; let y = calYear; if(m > 11) { m=0; y++; } else if(m < 0) { m=11; y--; } setCalMonth(m); setCalYear(y); };
            
            // FIXED: Enhanced category intelligence for charts
            const enhancedPieData = useMemo(() => {
                const categoryGroups = {};
                
                // Group by main categories
                stats.pieData.forEach(item => {
                    const mainCategory = normalizeCategory(item.name);
                    categoryGroups[mainCategory] = (categoryGroups[mainCategory] || 0) + item.value;
                });
                
                // Sort by value (descending)
                const sortedGroups = Object.entries(categoryGroups)
                    .sort(([,a], [,b]) => b - a)
                    .map(([name, value], index) => ({ 
                        name, 
                        value,
                        color: COLORS[index % COLORS.length]
                    }));
                
                return sortedGroups;
            }, [stats.pieData]);
            
            // FIXED: Calendar View Rendering
            const renderCalendarView = () => {
                return (
                    <div className="space-y-4">
                        <div className="flex justify-between items-center px-4">
                            <button onClick={() => changeMonth(-1)} className="p-2 rounded-full bg-slate-100 dark:bg-slate-800">
                                <i data-lucide="chevron-left" className="w-5 h-5"></i>
                            </button>
                            <h3 className="font-bold dark:text-white">
                                {new Date(calYear, calMonth).toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}
                            </h3>
                            <button onClick={() => changeMonth(1)} className="p-2 rounded-full bg-slate-100 dark:bg-slate-800">
                                <i data-lucide="chevron-right" className="w-5 h-5"></i>
                            </button>
                        </div>
                        <div className="grid grid-cols-7 gap-1 px-4">
                            {['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map(day => (
                                <div key={day} className="text-center text-xs font-bold text-slate-400 py-2">{day}</div>
                            ))}
                            {calendarGrid.map((day, idx) => (
                                <div key={idx} className={`min-h-12 p-1 ${!day ? 'invisible' : ''}`}>
                                    {day && (
                                        <button
                                            onClick={() => {
                                                setSelectedDate(day.date);
                                                setIsCalendarMode(false);
                                            }}
                                            className={`w-full h-full rounded-lg flex flex-col items-center justify-center text-sm font-bold transition-all
                                                ${selectedDate === day.date ? 'bg-indigo-500 text-white' : 
                                                  'bg-white dark:bg-slate-800 hover:bg-slate-100 dark:hover:bg-slate-700'}`}
                                        >
                                            <span>{day.day}</span>
                                            <div className="flex gap-1 mt-1">
                                                {day.hasInc && <div className="w-1.5 h-1.5 rounded-full bg-emerald-500"></div>}
                                                {day.hasExp && <div className="w-1.5 h-1.5 rounded-full bg-red-500"></div>}
                                            </div>
                                        </button>
                                    )}
                                </div>
                            ))}
                        </div>
                    </div>
                );
            };
            
            return (
                <div className="h-full w-full flex flex-col bg-slate-50 dark:bg-slate-950">
                    <header className="px-6 py-4 bg-white dark:bg-slate-900 border-b border-slate-200 dark:border-slate-800 flex justify-between items-center z-20">
                        <div className="flex items-center gap-3"><Avatar imageId={currentUser.imageId} name={currentUser.name} theme={theme} /><div><h1 className="font-bold dark:text-white leading-tight">Hi, {currentUser.name.split(' ')[0]}</h1></div></div>
                        <div className="flex gap-2">
                            <button onClick={handleRefresh} className={`icon-btn flex items-center justify-center ${refreshing ? 'animate-spin-once' : ''}`} style={{color: THEMES[theme].bg, transition: 'all 0.3s'}}><i data-lucide="refresh-cw" className="w-5 h-5"></i></button>
                            <button onClick={()=>setDarkMode(!darkMode)} className="icon-btn"><i data-lucide={darkMode?"sun":"moon"} className="w-5 h-5"></i></button>
                            <button onClick={onLogout} className="icon-btn text-red-500 bg-red-50 dark:bg-red-900/20"><i data-lucide="log-out" className="w-5 h-5"></i></button>
                        </div>
                    </header>
                    <div className="flex-1 overflow-y-auto p-4 pb-24 space-y-6">
                       
                        {view === 'home' && (
                            <div className="space-y-6 animate-fade">
                                <div className="glass p-6 rounded-[2rem] text-white shadow-xl shadow-indigo-500/30" style={{background: `linear-gradient(135deg, ${THEMES[theme].bg} 0%, #1e1b4b 100%)`}}>
                                    <p className="text-white/70 text-xs font-bold uppercase tracking-wider mb-1">Total Actual Balance</p>
                                    <h2 className="text-4xl font-bold">{formatMoney(stats.total)}</h2>
                                    <div className="mt-6 flex gap-3">
                                        <div className="bg-white/10 px-4 py-2 rounded-xl border border-white/10 backdrop-blur-md flex-1"><p className="text-[10px] text-white/70 font-bold uppercase">Online</p><p className="font-bold text-lg">{formatMoney(stats.onlineBal)}</p></div>
                                        <div className="bg-white/10 px-4 py-2 rounded-xl border border-white/10 backdrop-blur-md flex-1"><p className="text-[10px] text-white/70 font-bold uppercase">Cash</p><p className="font-bold text-lg">{formatMoney(stats.cashBal)}</p></div>
                                    </div>
                                </div>
                                <div className="p-3 bg-blue-50 dark:bg-blue-900/20 text-blue-600 dark:text-blue-300 text-xs font-bold rounded-xl flex items-center gap-3 border border-blue-100 dark:border-blue-900/50"><i data-lucide="sparkles" className="w-5 h-5 shrink-0"></i>{stats.insight}</div>
                                {parseInt(budget) > 0 && (<div className="bg-white dark:bg-slate-900 p-4 rounded-[1.5rem] shadow-sm border border-slate-200 dark:border-slate-800"><div className="flex justify-between text-xs font-bold mb-2"><span className="text-slate-500">Monthly Budget</span><span>{formatMoney(stats.pieData.reduce((a,b)=>a+b.value,0))} / {formatMoney(budget)}</span></div><div className="h-3 bg-slate-100 dark:bg-slate-800 rounded-full overflow-hidden"><div className={`h-full rounded-full transition-all duration-500 ${THEMES[theme].class}`} style={{width: `${Math.min(100, (stats.pieData.reduce((a,b)=>a+b.value,0)/parseInt(budget))*100)}%`}}></div></div></div>)}
                                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                                    <div className="bg-white dark:bg-slate-900 p-5 rounded-[1.5rem] shadow-sm"><p className="text-[10px] font-bold text-slate-400 uppercase mb-1">Assets (Rented)</p><p className="text-xl font-bold" style={{color: accentColor}}>{formatMoney(stats.rented)}</p></div>
                                    <div className="bg-white dark:bg-slate-900 p-5 rounded-[1.5rem] shadow-sm"><p className="text-[10px] font-bold text-slate-400 uppercase mb-1">Liabilities (Taken)</p><p className="text-xl font-bold" style={{color: accentColor}}>{formatMoney(stats.taken)}</p></div>
                                </div>
                                <div className="flex justify-center bg-slate-100 dark:bg-slate-800 p-1 rounded-xl">{['trend', 'bar', 'pie'].map(g => (<button key={g} onClick={()=>setActiveGraph(g)} className={`flex-1 py-2 text-xs font-bold rounded-lg capitalize transition-all ${activeGraph===g ? 'bg-white dark:bg-slate-700 shadow text-slate-900 dark:text-white' : 'text-slate-400'}`}>{g === 'trend' ? 'Cash Flow' : g === 'bar' ? 'Analysis' : 'Category'}</button>))}</div>
                                <div className="h-64 bg-white dark:bg-slate-900 rounded-[2rem] p-4 shadow-sm border border-slate-200 dark:border-slate-800">
                                    <ResponsiveContainer width="100%" height="100%">
                                        {activeGraph === 'trend' ? (
                                            <AreaChart data={stats.graphArea}>
                                                <defs><linearGradient id="c" x1="0" y1="0" x2="0" y2="1"><stop offset="5%" stopColor={THEMES[theme].bg} stopOpacity={0.3}/><stop offset="95%" stopColor={THEMES[theme].bg} stopOpacity={0}/></linearGradient></defs>
                                                <Tooltip contentStyle={{backgroundColor:'#0f172a', border:'none', borderRadius:'12px', color:'#fff'}} formatter={(value) => formatMoney(value)} />
                                                <Area type="monotone" dataKey="val" stroke={THEMES[theme].bg} fill="url(#c)" strokeWidth={3} />
                                            </AreaChart>
                                        ) : activeGraph === 'bar' ? (
                                            <BarChart data={stats.barData}>
                                                <XAxis dataKey="name" tick={{fontSize: 10}} stroke="#94a3b8" />
                                                <Tooltip contentStyle={{backgroundColor:'#0f172a', border:'none', borderRadius:'12px', color:'#fff'}} formatter={(value) => formatMoney(value)} cursor={{fill: 'transparent'}} />
                                                <Bar dataKey="value" fill={THEMES[theme].bg} radius={[4, 4, 0, 0]} />
                                            </BarChart>
                                        ) : (
                                            <PieChart>
                                                <Pie data={enhancedPieData} innerRadius={60} outerRadius={80} paddingAngle={5} dataKey="value" nameKey="name">
                                                    {enhancedPieData.map((entry, index) => (<Cell key={`cell-${index}`} fill={entry.color} />))}
                                                </Pie>
                                                <Tooltip contentStyle={{backgroundColor:'#0f172a', border:'none', borderRadius:'12px', color:'#fff'}} formatter={(value) => formatMoney(value)} />
                                                <Legend />
                                            </PieChart>
                                        )}
                                    </ResponsiveContainer>
                                </div>
                            </div>
                        )}
                        
                        {/* FINANCIAL CORRECTNESS: Enhanced Requests Tab with Multi-Stage Flow */}
                        {view === 'requests' && (
                            <div className="space-y-4 animate-fade">
                                <h2 className="text-xl font-bold dark:text-white px-2">Transaction Requests</h2>
                                {requests.length === 0 && <p className="text-center text-slate-400 mt-10">No pending requests.</p>}
                                {requests.map(t => {
                                    const isMine = t.userId === currentUser.id;
                                    const isSynced = !isMine;
                                    
                                    // For synced transactions, mirror the type for display
                                    let displayType = t.type;
                                    if (isSynced) {
                                        if(t.type === 'lent') displayType = 'borrowed'; 
                                        else if(t.type === 'borrowed') displayType = 'lent';
                                        else if(t.type === 'repayment_in') displayType = 'repayment_out'; 
                                        else if(t.type === 'repayment_out') displayType = 'repayment_in';
                                    }
                                    
                                    const isPending = t.status === 'Pending';
                                    const isApproved = t.status === 'Approved';
                                    const isMarkedPaid = t.status === 'Marked as Paid';
                                    
                                    // Determine who this request is for
                                    const isForRecipient = isSynced && (isPending || isApproved);
                                    const isForCreator = isMine && isMarkedPaid;
                                    
                                    // Get friend name for creator view
                                    let payerName = 'Friend';
                                    if (isForCreator && t.relatedEmail) {
                                        const friend = data.people.find(p => p.email && p.email.toLowerCase() === t.relatedEmail.toLowerCase());
                                        payerName = friend ? friend.name : t.relatedEmail.split('@')[0];
                                    }
                                    
                                    return (
                                        <div key={t.id} className="p-4 bg-white dark:bg-slate-900 rounded-2xl border border-indigo-200 dark:border-indigo-900 shadow-sm">
                                            <div className="flex justify-between items-start mb-4">
                                                <div>
                                                    <p className="text-xs font-bold text-indigo-500 uppercase tracking-wider mb-1">
                                                        {isForCreator 
                                                            ? `ðŸ’° Payment from ${payerName}`
                                                            : `ðŸ“¥ Request from ${t.creatorEmail ? t.creatorEmail.split('@')[0] : 'Unknown'}`
                                                        }
                                                    </p>
                                                    <p className="font-bold dark:text-white text-lg">{t.category}</p>
                                                    <p className="text-slate-400 text-sm">{t.description}</p>
                                                    <div className="mt-2">
                                                        <TransactionStateBadge status={t.status} theme={theme} />
                                                    </div>
                                                </div>
                                                <div className="text-right">
                                                    <span className="font-bold text-xl block dark:text-white">{formatMoney(t.amount)}</span>
                                                    <span className={`text-[10px] font-bold uppercase px-2 py-1 rounded ${
                                                        isForCreator 
                                                            ? 'bg-emerald-100 text-emerald-600' 
                                                            : displayType === 'borrowed' 
                                                                ? 'bg-amber-100 text-amber-600' 
                                                                : 'bg-blue-100 text-blue-600'
                                                    }`}>
                                                        {isForCreator 
                                                            ? 'You Received' 
                                                            : displayType === 'borrowed' 
                                                                ? 'You Owe' 
                                                                : 'They Owe'
                                                        }
                                                    </span>
                                                </div>
                                            </div>
                                            
                                            {/* Multi-stage action buttons - Different for recipient vs creator */}
                                            <div className="flex flex-col sm:flex-row gap-3">
                                                {/* RECIPIENT ACTIONS: Approve/Reject and Mark as Paid */}
                                                {isForRecipient && isPending && (
                                                    <>
                                                        <button onClick={()=>handleApproval(t, 'Rejected')} className="flex-1 py-3 rounded-xl bg-red-50 text-red-600 font-bold border border-red-100 hover:bg-red-100 dark:bg-red-900/20 dark:border-red-900/50">
                                                            Reject
                                                        </button>
                                                        <button onClick={()=>handleApproval(t, 'Approved')} className="flex-1 py-3 rounded-xl bg-emerald-50 text-emerald-600 font-bold border border-emerald-100 hover:bg-emerald-100 dark:bg-emerald-900/20 dark:border-emerald-900/50">
                                                            Approve
                                                        </button>
                                                    </>
                                                )}
                                                
                                                {isForRecipient && isApproved && (
                                                    <>
                                                        <button onClick={()=>handleApproval(t, 'Marked as Paid')} className="flex-1 py-3 rounded-xl bg-blue-50 text-blue-600 font-bold border border-blue-100 hover:bg-blue-100 dark:bg-blue-900/20 dark:border-blue-900/50">
                                                            Mark as Paid
                                                        </button>
                                                        <button onClick={()=>{
                                                            // Try to get friend's UPI ID if available
                                                            const friend = data.people.find(p => p.email === t.creatorEmail);
                                                            const upiId = friend?.phone || t.creatorEmail || 'example@upi';
                                                            window.open(`upi://pay?pa=${upiId}&pn=${t.creatorEmail?.split('@')[0] || 'Friend'}&am=${t.amount}&cu=INR`, '_blank');
                                                        }} className="flex-1 py-3 rounded-xl bg-indigo-50 text-indigo-600 font-bold border border-indigo-100 hover:bg-indigo-100 dark:bg-indigo-900/20 dark:border-indigo-900/50">
                                                            Pay Now (UPI)
                                                        </button>
                                                    </>
                                                )}
                                                
                                                {/* CREATOR ACTIONS: Confirm Receipt or Not Received */}
                                                {isForCreator && isMarkedPaid && (
                                                    <>
                                                        <button onClick={()=>handlePaymentConfirmation(t, 'Not Received')} className="flex-1 py-3 rounded-xl bg-amber-50 text-amber-600 font-bold border border-amber-100 hover:bg-amber-100 dark:bg-amber-900/20 dark:border-amber-900/50">
                                                            Not Received
                                                        </button>
                                                        <button onClick={()=>handlePaymentConfirmation(t, 'Confirmed')} className="flex-1 py-3 rounded-xl bg-emerald-50 text-emerald-600 font-bold border border-emerald-100 hover:bg-emerald-100 dark:bg-emerald-900/20 dark:border-emerald-900/50">
                                                            âœ“ Confirm Receipt
                                                        </button>
                                                    </>
                                                )}
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        )}
                        
                        {(view === 'history' || (view === 'people' && selectedFriend)) && (
                            <div className="space-y-4 animate-fade">
                                <div className="flex justify-between items-center px-2">
                                    <h2 className="text-xl font-bold dark:text-white">{selectedFriend ? `History w/ ${selectedFriend.name}` : isCalendarMode ? 'Calendar View' : 'Transactions'}</h2>
                                    {!selectedFriend && <button onClick={()=>setIsCalendarMode(!isCalendarMode)} className={`p-2 rounded-full ${isCalendarMode ? THEMES[theme].class + ' text-white' : 'bg-slate-200 dark:bg-slate-800 text-slate-500'}`}><i data-lucide={isCalendarMode?"list":"calendar"} className="w-5 h-5"></i></button>}
                                </div>
                               
                                {/* Calendar View */}
                                {isCalendarMode && renderCalendarView()}
                               
                                {/* Regular History View */}
                                {!isCalendarMode && (
                                    <>
                                        {/* TASK 1: History Section Date Filters */}
                                        {!selectedFriend && (
                                            <div className="px-2 space-y-3">
                                                <div className="scroll-x flex gap-2 pb-1">
                                                    {[
                                                        { id: 'TODAY', label: 'Today' },
                                                        { id: 'YESTERDAY', label: 'Yesterday' },
                                                        { id: '7', label: 'Last 7 Days' },
                                                        { id: '30', label: 'Last 30 Days' },
                                                        { id: 'RANGE', label: 'Range' },
                                                        { id: 'ALL', label: 'All Time' }
                                                    ].map(f => (
                                                        <button key={f.id} onClick={()=>{
                                                            setFilterDays(f.id);
                                                            const now = new Date(); now.setHours(0,0,0,0);
                                                            if(f.id === 'TODAY') { const s = now.toISOString().split('T')[0]; setDateFrom(s); setDateTo(s); }
                                                            else if(f.id === 'YESTERDAY') { const y = new Date(now); y.setDate(y.getDate()-1); const s = y.toISOString().split('T')[0]; setDateFrom(s); setDateTo(s); }
                                                            else if(f.id === 'RANGE') { const s = now.toISOString().split('T')[0]; setDateFrom(s); setDateTo(s); }
                                                            else { setDateFrom(null); setDateTo(null); }
                                                        }} className={`px-4 py-2 rounded-full text-[10px] font-bold uppercase tracking-tight transition-all ${filterDays===f.id ? THEMES[theme].class + ' text-white shadow-md' : 'bg-white dark:bg-slate-900 text-slate-500 border border-slate-200 dark:border-slate-800'}`}>{f.label}</button>
                                                    ))}
                                                </div>
                                                {filterDays === 'RANGE' && (
                                                    <div className="flex items-center gap-2 animate-fade">
                                                        <span className="text-xs font-bold text-slate-400 uppercase">From</span>
                                                        <input type="date" className="p-2 rounded-lg bg-white dark:bg-slate-900 border border-slate-200 dark:border-slate-800 text-sm outline-none" value={dateFrom || ''} onChange={e=>setDateFrom(e.target.value)} />
                                                        <span className="text-xs font-bold text-slate-400 uppercase">To</span>
                                                        <input type="date" className="p-2 rounded-lg bg-white dark:bg-slate-900 border border-slate-200 dark:border-slate-800 text-sm outline-none" value={dateTo || ''} onChange={e=>setDateTo(e.target.value)} />
                                                        <button onClick={()=>{ setFilterDays('RANGE'); }} className="py-1 px-2 rounded-md text-xs bg-slate-100 dark:bg-slate-800">Apply</button>
                                                    </div>
                                                )}

                                                {/* Transaction Type Filters: ALL / INCOMING / OUTGOING / REPAYMENT */}
                                                <div className="flex items-center gap-2 mt-3">
                                                    <span className="text-xs font-bold text-slate-400 uppercase">Type</span>
                                                    {[
                                                        { id: 'ALL', label: 'All' },
                                                        { id: 'INCOMING', label: 'Incoming' },
                                                        { id: 'OUTGOING', label: 'Outgoing' },
                                                        { id: 'REPAYMENT', label: 'Repayment' }
                                                    ].map(ft => (
                                                        <button key={ft.id} onClick={() => setFilterType(ft.id)} className={`px-3 py-2 rounded-full text-[10px] font-bold uppercase tracking-tight transition-all ${filterType===ft.id ? THEMES[theme].class + ' text-white shadow-md' : 'bg-white dark:bg-slate-900 text-slate-500 border border-slate-200 dark:border-slate-800'}`}>
                                                            {ft.label}
                                                        </button>
                                                    ))}
                                                </div>
                                            </div>
                                        )}
                                        {/* TASK 2: History Summary Cards */}
                                        <div className="grid grid-cols-2 gap-3 px-2">
                                            <div className="bg-white dark:bg-slate-900 p-4 rounded-2xl border border-slate-100 dark:border-slate-800 shadow-sm">
                                                <div className="flex items-center gap-2 mb-1">
                                                    <div className="w-2 h-2 rounded-full bg-emerald-500"></div>
                                                    <p className="text-[10px] font-bold text-slate-400 uppercase mb-1">Incoming</p>
                                                </div>
                                                <p className="text-lg font-bold text-emerald-600">{formatMoney(historySummary.in)}</p>
                                            </div>
                                            <div className="bg-white dark:bg-slate-900 p-4 rounded-2xl border border-slate-100 dark:border-slate-800 shadow-sm">
                                                <div className="flex items-center gap-2 mb-1">
                                                    <div className="w-2 h-2 rounded-full bg-red-500"></div>
                                                    <p className="text-[10px] font-bold text-slate-400 uppercase mb-1">Outgoing</p>
                                                </div>
                                                <p className="text-lg font-bold text-red-600">{formatMoney(historySummary.out)}</p>
                                            </div>
                                        </div>
                                        <div className="px-4 mb-2"><div className="flex items-center bg-white dark:bg-slate-900 rounded-xl px-3 py-3 border border-slate-200 dark:border-slate-800"><i data-lucide="search" className="w-4 h-4 text-slate-400 mr-2"></i><input className="bg-transparent outline-none w-full text-sm dark:text-white" placeholder="Search..." value={searchTerm} onChange={e => setSearchTerm(e.target.value)} /></div></div>
                                       
                                        {filteredHistory.length === 0 && <p className="text-center text-slate-400 mt-10">No transactions found.</p>}
                                       
                                        {filteredHistory.map(t => {
                                            const isMine = t.userId === currentUser.id;
                                            let effectiveType = t.type; 
                                            let displayType = t.type;
                                            const whoPaidText = isMine ? "Paid by You" : `Paid by ${t.creatorEmail?.split('@')[0] || 'Unknown'}`;
                                            const normalizedCategory = normalizeCategory(t.category);
                                            
                                            if(selectedFriend) {
                                                const friendEmail = selectedFriend.email ? selectedFriend.email.toLowerCase() : "";
                                                const creatorEmail = t.creatorEmail ? t.creatorEmail.toLowerCase() : "";
                                                const isRelated = (isMine && t.relatedPerson === selectedFriend.id) || (!isMine && creatorEmail === friendEmail);
                                                if(!isRelated) return null;
                                            }
                                            
                                            if(!isMine) { 
                                                if (t.type === 'lent') effectiveType = 'borrowed'; 
                                                else if (t.type === 'borrowed') effectiveType = 'lent'; 
                                                else if (t.type === 'repayment_in') effectiveType = 'repayment_out'; 
                                                else if (t.type === 'repayment_out') effectiveType = 'repayment_in'; 
                                                displayType = effectiveType; 
                                            }
                                            
                                            return (
                                                <div key={t.id} onClick={() => isMine ? (setEditItem(t), setModal('add')) : alert("Synced Transaction. Cannot edit.")} className={`flex justify-between items-center p-4 bg-white dark:bg-slate-900 rounded-2xl border ${!isMine ? 'border-dashed border-indigo-300 dark:border-indigo-800' : 'border-slate-200 dark:border-slate-800'} shadow-sm cursor-pointer hover:bg-slate-50 dark:hover:bg-slate-800 transition`}>
                                                    <div className="flex gap-4 items-center">
                                                        <div className={`w-12 h-12 rounded-2xl flex items-center justify-center text-xl shrink-0 ${displayType.includes('income')?'bg-emerald-50 text-emerald-600 dark:bg-emerald-900/20':displayType.includes('expense')?'bg-red-50 text-red-600 dark:bg-red-900/20':'bg-blue-50 text-blue-600 dark:bg-blue-900/20'}`}>
                                                            <i data-lucide={displayType==='income'?'arrow-down':displayType==='expense'?'arrow-up':'refresh-cw'} className="w-5 h-5"></i>
                                                        </div>
                                                        <div className="min-w-0">
                                                            <p className="text-[10px] font-bold text-slate-400 uppercase tracking-wide">{whoPaidText}</p>
                                                            <div className="flex items-center gap-2">
                                                                <TransactionStateBadge status={t.status} theme={theme} iconOnly={true} small={true} />
                                                                <p className="font-bold text-sm dark:text-white truncate">
                                                                    {t.category} 
                                                                    {normalizedCategory !== t.category && <span className="text-[10px] text-slate-500 ml-1">({normalizedCategory})</span>}
                                                                    {!isMine && <span className="text-[10px] text-indigo-500 bg-indigo-50 px-1 rounded ml-1">SYNC</span>}
                                                                </p>
                                                            </div>
                                                            <div className="flex items-center gap-1">
                                                                <p className="text-xs text-slate-500 font-medium">{t.date.split('T')[0]} â€¢ {t.paymentMode}</p>
                                                                {t.imageId && <i data-lucide="paperclip" className="w-3 h-3 text-indigo-500"></i>}
                                                            </div>
                                                        </div>
                                                    </div>
                                                    <div className="text-right shrink-0">
                                                        <span className="font-bold block dark:text-white text-lg">{formatMoney(t.amount)}</span>
                                                        <span className="text-[10px] font-bold uppercase text-slate-400">
                                                            {displayType==='income'?'In':displayType==='expense'?'Out':displayType==='borrowed'?'Debt':'Lent'}
                                                        </span>
                                                    </div>
                                                </div>
                                            );
                                        })}
                                    </>
                                )}
                            </div>
                        )}
                        
                        {view === 'people' && !selectedFriend && (
                            <div className="space-y-4 animate-fade">
                                <div className="px-4 mb-2"><div className="flex items-center bg-white dark:bg-slate-900 rounded-xl px-3 py-3 border border-slate-200 dark:border-slate-800"><i data-lucide="search" className="w-4 h-4 text-slate-400 mr-2"></i><input className="bg-transparent outline-none w-full text-sm dark:text-white" placeholder="Search friends..." value={searchTerm} onChange={e => setSearchTerm(e.target.value)} /></div></div>
                                <div className="flex justify-between items-center px-2"><h2 className="text-xl font-bold dark:text-white">Friends</h2><button onClick={()=>{setEditItem(null); setModal('person');}} className={`text-white px-3 py-2 rounded-md text-xs font-bold shadow-lg ${THEMES[theme].class}`}>+ Add Friend</button></div>
                                {stats.peopleStats.filter(p=>p.name.toLowerCase().includes(searchTerm.toLowerCase())).map(p => {
                                    // FIXED: Correct display logic for friend balances
                                    const displayText = p.net > 0 
                                        ? `You will get ${formatMoney(p.net)}` 
                                        : p.net < 0 
                                            ? `You need to pay ${formatMoney(Math.abs(p.net))}`
                                            : 'Settled';
                                    
                                    const displayColor = p.net > 0 
                                        ? 'text-emerald-500' 
                                        : p.net < 0 
                                            ? 'text-red-500' 
                                            : 'text-slate-400';
                                    
                                    return (
                                        <div key={p.id} onClick={()=>setSelectedFriend(p)} className="flex items-center justify-between p-3 sm:p-4 bg-white dark:bg-slate-900 rounded-2xl border border-slate-200 dark:border-slate-800 shadow-sm cursor-pointer hover:bg-slate-50 dark:hover:bg-slate-800">
                                            <div className="flex items-center gap-3">
                                                <Avatar imageId={p.imageId} name={p.name} theme={theme} />
                                                <div>
                                                    <div className="flex items-center gap-2">
                                                        <p className="font-bold dark:text-white">{p.name}</p>
                                                        {p.email && <span className="text-[10px] bg-indigo-100 text-indigo-600 px-1 rounded font-bold">LINKED</span>}
                                                        {!p.email && <span className="text-[10px] bg-amber-100 text-amber-700 px-1 rounded font-bold">MANUAL</span>}
                                                    </div>
                                                    <p className={`text-xs font-bold ${displayColor}`}>
                                                        {displayText}
                                                    </p>
                                                </div>
                                            </div>
                                            <button onClick={(e)=>{e.stopPropagation(); removePerson(p);}} className="p-2 text-slate-400 hover:text-red-500 hover:bg-red-50 dark:hover:bg-red-900/20 rounded-full transition"><i data-lucide="trash-2" className="w-4 h-4"></i></button>
                                        </div>
                                    );
                                })}
                            </div>
                        )}
                        
                        {view === 'profile' && (
                            <div className="space-y-6 animate-fade">
                                <ProfileView user={currentUser} onUpdate={u => setCurrentUser(u)} theme={theme} setTheme={setTheme} setAccentColor={setAccentColor} mutate={mutate} />
                                <div className="px-4"><p className="text-xs font-bold text-slate-400 uppercase mb-3">Settings</p>
                                    <div className="bg-white dark:bg-slate-900 rounded-[1.5rem] p-4 space-y-4">
                                        <div className="flex justify-between items-center"><span className="text-sm font-bold dark:text-white">Monthly Budget</span><input type="number" className="w-24 text-right bg-slate-100 dark:bg-slate-800 rounded-lg px-2 py-1 text-sm outline-none" placeholder="0" value={budget} onChange={e=>{setBudget(e.target.value); localStorage.setItem('fm_budget', e.target.value);}} /></div>
                                        <div className="flex justify-between items-center theme-row"><span className="text-sm font-bold dark:text-white">Theme</span>
                                            <div className="flex gap-2 items-center min-w-0">
                                                <div className="theme-swatches flex-1 flex flex-wrap gap-2 min-w-0">
                                                    {Object.keys(THEMES).map(c => (
                                                        <button key={c} onClick={()=>{setTheme(c); localStorage.setItem('fm_theme', c); setAccentColor(THEMES[c].bg);}} className={`swatch w-6 h-6 rounded-full cursor-pointer border-2 ${theme===c?'border-slate-900 dark:border-white':'border-transparent'}`} style={{backgroundColor:THEMES[c].bg}} aria-label={`Theme ${c}`} title={c}></button>
                                                    ))}
                                                </div>
                                                <input type="color" value={accentColor} onChange={e=>{setAccentColor(e.target.value); localStorage.setItem('fm_accent', e.target.value);}} className="ml-2 w-8 h-8 p-0 border-0" />
                                            </div>
                                        </div>
                                        <button onClick={exportCSV} className="w-full py-3 bg-slate-100 dark:bg-slate-800 text-slate-600 dark:text-slate-300 font-bold rounded-xl text-sm flex justify-center gap-2"><i data-lucide="download" className="w-4 h-4"></i> Export Data (CSV)</button>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                    <button onClick={()=>{setEditItem(null); setModal('add');}} className={`absolute bottom-16 sm:bottom-24 right-4 sm:right-6 w-12 sm:w-16 h-12 sm:h-16 text-white rounded-full shadow-xl flex items-center justify-center z-30 transition-transform active:scale-90 ${THEMES[theme].class}`}><i data-lucide="plus" className="w-6 sm:w-8 h-6 sm:h-8"></i></button>
                    <div className="absolute bottom-0 w-full bg-white dark:bg-slate-900 border-t border-slate-200 dark:border-slate-800 px-4 py-3 sm:px-6 flex justify-between items-center z-40 pb-safe">
                        {['home','history','people','requests','profile'].map(v => (
                            <button key={v} onClick={()=>{setView(v); setSelectedFriend(null); setIsCalendarMode(false);}} className={`flex flex-col items-center gap-1 transition-all ${view===v?THEMES[theme].text + ' scale-110':'text-slate-400 dark:text-slate-600'}`}>
                                <div className="relative"><i data-lucide={v==='home'?'home':v==='history'?'list':v==='people'?'users':v==='requests'?'bell':'user'} className={`w-6 h-6 ${view===v && 'fill-current opacity-20'}`}></i>{v==='requests' && requests.length > 0 && <span className="absolute -top-1 -right-1 w-3 h-3 bg-red-500 rounded-full border-2 border-white dark:border-slate-900"></span>}</div>
                            </button>
                        ))}
                    </div>
                    {selectedFriend && (
                        <div className="absolute top-0 left-0 w-full h-20 bg-white dark:bg-slate-900 flex items-center px-4 z-50 border-b border-slate-200 dark:border-slate-800 animate-fade">
                            <button onClick={()=>setSelectedFriend(null)} className="p-2 -ml-2 text-slate-500"><i data-lucide="arrow-left" className="w-6 h-6"></i></button>
                            <div className="ml-3 flex items-center gap-3">
                                <Avatar imageId={selectedFriend.imageId} name={selectedFriend.name} theme={theme} />
                                <div>
                                    <h2 className="font-bold text-lg dark:text-white">{selectedFriend.name}</h2>
                                    <p className={`text-xs font-bold ${selectedFriend.net > 0 ? 'text-emerald-500' : selectedFriend.net < 0 ? 'text-red-500' : 'text-slate-400'}`}>
                                        {selectedFriend.net > 0 
                                            ? `Owes you ${formatMoney(selectedFriend.net)}` 
                                            : selectedFriend.net < 0 
                                                ? `You owe ${formatMoney(Math.abs(selectedFriend.net))}` 
                                                : 'Settled'}
                                    </p>
                                </div>
                            </div>
                        </div>
                    )}
                    <ConfirmDialog isOpen={dialog.isOpen} title={dialog.title} msg={dialog.msg} onConfirm={dialog.onConfirm} onCancel={dialog.onCancel} type={dialog.type} theme={theme} single={dialog.single} confirmLabel={dialog.confirmLabel} />
                   
                    {rejectedItems.length > 0 && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center bg-slate-900/60 backdrop-blur-sm p-4 animate-fade">
                            <div className="bg-white dark:bg-slate-900 w-full max-w-sm rounded-[2rem] p-6 shadow-2xl animate-up relative text-center">
                                <button onClick={()=>setRejectedItems(prev=>prev.slice(1))} className="absolute top-4 right-4 text-slate-400 hover:text-slate-600"><i data-lucide="x" className="w-5 h-5"></i></button>
                                <div className="w-16 h-16 bg-red-100 text-red-500 rounded-full flex items-center justify-center mx-auto mb-4"><i data-lucide="alert-circle" className="w-8 h-8"></i></div>
                                <h3 className="font-bold text-xl dark:text-white mb-2">Request Rejected</h3>
                                <p className="text-slate-500 text-sm mb-6">Your transaction "{rejectedItems[0].description}" of {formatMoney(rejectedItems[0].amount)} was rejected.</p>
                                <div className="flex gap-3">
                                    <button onClick={()=>{confirmAction('Delete Record?', 'This will permanently delete this rejected request.', ()=>{ mutate({ action:'delete', id:rejectedItems[0].id, userId:currentUser.id }).then(json => { if(!json || json.success === false) alert(json?.error || 'Error'); setRejectedItems(prev => prev.slice(1)); }); }, 'danger');}} className="flex-1 py-3 rounded-xl bg-red-50 text-red-600 font-bold">Delete</button>
                                    <button onClick={async ()=>{ const { id, status, ...retryData } = rejectedItems[0]; if(retryData.date) retryData.date = retryData.date.split('T')[0]; try { setLoading(true); const json = await mutate({ action:'delete', id:rejectedItems[0].id, userId:currentUser.id }); if(json && json.success) { setEditItem(retryData); setModal('add'); setRejectedItems(prev => prev.slice(1)); } else { alert(json?.error || 'Error'); } } catch (e) { alert('Error'); } finally { setLoading(false); } }} className={`flex-1 py-3 rounded-xl text-white font-bold shadow-lg ${THEMES[theme].class}`}>Retry</button>
                                </div>
                            </div>
                        </div>
                    )}
                   
                    {modal === 'add' && <TransactionModal user={currentUser} people={data.people} editItem={editItem} onClose={()=>{setModal(null); fetchData(lastFetchParams);}} theme={theme} mutate={mutate} setData={setData} data={data} fetchData={fetchData} lastFetchParams={lastFetchParams} setDialog={setDialog} /> }
                    {modal === 'person' && <PersonModal user={currentUser} onClose={()=>{setModal(null); fetchData(lastFetchParams);}} theme={theme} mutate={mutate} /> }
                </div>
            );
        }
        
        // FIXED: Enhanced Transaction Modal with Smart Split Logic
        function TransactionModal({ user, people, editItem, onClose, theme, mutate, setData, data, fetchData, lastFetchParams, setDialog }) {
            const [tab, setTab] = useState(editItem ? (['lent','borrowed','repayment_in','repayment_out'].includes(editItem.type)?'friend':'simple') : 'simple');
            const [splitMode, setSplitMode] = useState('equal');
            const [includeMe, setIncludeMe] = useState(true);
            const [selectedFriends, setSelectedFriends] = useState([]);
            const [splitAmounts, setSplitAmounts] = useState({});
            const [lockedAmounts, setLockedAmounts] = useState({});
            const [form, setForm] = useState(editItem ? { 
                ...editItem, 
                date: editItem.date ? editItem.date.split('T')[0] : new Date().toISOString().split('T')[0], 
                totalBill: editItem.totalBill || '',
                amount: editItem.amount || '',
                category: editItem.category || 'General'
            } : { 
                type: 'expense', 
                amount: '', 
                category: 'General', 
                description: '', 
                date: new Date().toISOString().split('T')[0], 
                relatedPerson: '', 
                paymentMode: 'Online', 
                totalBill: '' 
            });
            const [loading, setLoading] = useState(false);
            // Reminder UI state (non-destructive, persists locally)
            const [reminderSent, setReminderSent] = useState(() => (editItem && editItem.id) ? (localStorage.getItem(`fm_reminder_${editItem.id}`) === '1') : false);
            const [sendingReminder, setSendingReminder] = useState(false);
            const [reminderToast, setReminderToast] = useState(null);

            const showReminderToast = (title, sub) => {
                setReminderToast({ title, sub });
                setTimeout(() => setReminderToast(null), 3000);
            };

            const doSendReminder = async () => {
                if (!editItem || !editItem.id) return;
                // Safety: if transaction is no longer pending, show completed dialog and abort
                if (editItem.status !== 'Pending') {
                    setDialog({ isOpen: true, title: 'Payment already completed', msg: 'This payment has been settled and no reminder is needed.', single: true, confirmLabel: 'OK' });
                    return;
                }
                setSendingReminder(true);
                try {
                    const recipient = people.find(p => p.id === (editItem.relatedPerson || form.relatedPerson));
                    const name = recipient?.name || '';
                    const recipientEmail = recipient?.email || null;
                    const amountText = formatMoney(form.amount || editItem.amount || 0);
                    const message = `Payment reminder\nHi, this is a reminder that a payment of ${amountText} to ${name} is still pending.\nPlease complete it when convenient.`;
                    if (mutate) {
                        try { await mutate({ action: 'sendReminder', transactionId: editItem.id, userId: user.id, notifyOnly: true, message, recipientEmail }); } catch(e) { /* ignore */ }
                    } else {
                        try { await fetch(API_URL, { method: 'POST', body: JSON.stringify({ action: 'sendReminder', transactionId: editItem.id, notifyOnly: true, message, recipientEmail }) }); } catch(e) { /* ignore */ }
                    }
                    localStorage.setItem(`fm_reminder_${editItem.id}`, '1');
                    setReminderSent(true);
                    showReminderToast('Reminder sent', "Theyâ€™ve been notified about the pending payment.");
                } finally {
                    setSendingReminder(false);
                }
            };
            
            const totalBillCents = toCents(form.totalBill || 0);
            const sumSplitsCents = Object.values(splitAmounts).reduce((sum, val) => sum + toCents(val || 0), 0);
            const remainingCents = totalBillCents - sumSplitsCents;
            const [splitError, setSplitError] = useState(null);
            const isSplitValid = !splitError && (sumSplitsCents === totalBillCents);
            
            // Compute split allocation given manual/locked entries and participants.
            const computeSplitAllocation = (totalCents, participants, splits, locks) => {
                const manualCents = {};
                participants.forEach(id => {
                    if (locks[id]) {
                        const v = splits[id] || 0;
                        manualCents[id] = toCents(v || 0);
                    }
                });
                for (const v of Object.values(manualCents)) {
                    if (v < 0) return { error: 'Negative amounts are not allowed' };
                }
                const manualSum = Object.values(manualCents).reduce((s, v) => s + v, 0);
                if (manualSum > totalCents) return { error: `Manual amounts exceed total by ${formatMoney(fromCents(manualSum - totalCents))}` };
                const remaining = totalCents - manualSum;
                const remainingParticipants = participants.filter(id => !locks[id]);
                if (remainingParticipants.length === 0) {
                    if (remaining === 0) {
                        const out = {};
                        participants.forEach(id => { out[id] = manualCents[id] || 0; });
                        return { splitsCents: out };
                    } else {
                        return { error: 'No participants left to allocate remaining amount' };
                    }
                }
                const share = Math.floor(remaining / remainingParticipants.length);
                const remainder = remaining - share * remainingParticipants.length;
                const out = {};
                participants.forEach(id => {
                    if (manualCents[id] !== undefined) {
                        out[id] = manualCents[id];
                    } else {
                        const isLast = id === remainingParticipants[remainingParticipants.length - 1];
                        out[id] = share + (isLast ? remainder : 0);
                    }
                });
                const sum = Object.values(out).reduce((s, v) => s + v, 0);
                if (sum !== totalCents) return { error: 'Internal split mismatch' };
                for (const v of Object.values(out)) if (v < 0) return { error: 'Negative allocations detected' };
                return { splitsCents: out };
            };

            useEffect(() => {
                if (tab !== 'split') return;
                const participantList = [...selectedFriends];
                if (includeMe) participantList.unshift('me'); // me first so remainder goes to last participant
                if (participantList.length === 0) {
                    setSplitAmounts({});
                    setSplitError(null);
                    return;
                }

                // If there are no locked/manual entries, perform equal split using cents to avoid drift.
                const { splitsCents, error } = (() => {
                    if (totalBillCents === 0) return { splitsCents: {} };
                    const hasLocked = Object.keys(lockedAmounts).some(k => lockedAmounts[k]);
                    if (!hasLocked) {
                        const count = participantList.length;
                        const share = Math.floor(totalBillCents / count);
                        const remainder = totalBillCents - share * count;
                        const out = {};
                        participantList.forEach((id, idx) => {
                            out[id] = share + (idx === (participantList.length - 1) ? remainder : 0);
                        });
                        return { splitsCents: out };
                    }
                    // Otherwise use manual locks and redistribute remaining
                    return computeSplitAllocation(totalBillCents, participantList, splitAmounts, lockedAmounts);
                })();

                if (error) {
                    setSplitError(error);
                    return;
                } else {
                    setSplitError(null);
                }

                // Convert cents to decimal amounts for display
                const newSplits = {};
                Object.entries(splitsCents || {}).forEach(([id, cents]) => {
                    newSplits[id] = fromCents(cents);
                });

                setSplitAmounts(newSplits);

            }, [form.totalBill, selectedFriends, includeMe, splitMode, tab, totalBillCents, splitAmounts, lockedAmounts]);

            // When user edits a participant amount manually, lock it and validate immediately.
            const handleCustomSplitChange = (id, value) => {
                const parsed = parseFloat(value);
                if (isNaN(parsed) || parsed < 0) {
                    setSplitError('Enter a valid non-negative amount');
                    setSplitAmounts(prev => ({ ...prev, [id]: value }));
                    setLockedAmounts(prev => ({ ...prev, [id]: true }));
                    return;
                }
                // Lock the participant to prevent auto-overwrite
                setLockedAmounts(prev => ({ ...prev, [id]: true }));
                setSplitAmounts(prev => ({ ...prev, [id]: parsed }));
                setSplitError(null);
            };

            // Toggle lock state for a participant (icon button)
            const toggleLockAmount = (id) => {
                setLockedAmounts(prev => {
                    const next = { ...prev };
                    if (next[id]) delete next[id];
                    else next[id] = true;
                    return next;
                });
            };
            
            const toggleFriend = (id) => {
                if (selectedFriends.includes(id)) {
                    setSelectedFriends(prev => prev.filter(f => f !== id));
                    const newSplits = { ...splitAmounts };
                    const newLocked = { ...lockedAmounts };
                    delete newSplits[id];
                    delete newLocked[id];
                    setSplitAmounts(newSplits);
                    setLockedAmounts(newLocked);
                } else {
                    setSelectedFriends(prev => [...prev, id]);
                }
            };
           
            const handleImage = (e) => { const file = e.target.files[0]; if(file) compressImage(file).then(b64 => setForm({...form, imageBase64: b64})); };
           
            const submit = async (e) => {
                e.preventDefault();
                setLoading(true);
                
                // VALIDATION: Check required fields
                if (tab === 'simple') {
                    if (!form.amount || parseFloat(form.amount) <= 0) {
                        alert('Please enter a valid amount greater than 0');
                        setLoading(false);
                        return;
                    }
                    if (!form.category || form.category.trim() === '') {
                        alert('Please enter a category');
                        setLoading(false);
                        return;
                    }
                    if (!form.date) {
                        alert('Please select a date');
                        setLoading(false);
                        return;
                    }
                }
                
                if (tab === 'friend') {
                    if (!form.amount || parseFloat(form.amount) <= 0) {
                        alert('Please enter a valid amount greater than 0');
                        setLoading(false);
                        return;
                    }
                    if (!form.relatedPerson) {
                        alert('Please select a friend');
                        setLoading(false);
                        return;
                    }
                    if (!form.category || form.category.trim() === '') {
                        alert('Please enter a category');
                        setLoading(false);
                        return;
                    }
                    if (!form.date) {
                        alert('Please select a date');
                        setLoading(false);
                        return;
                    }
                }
                
                // FINANCIAL CORRECTNESS: Validate split sum equals total
                if (tab === 'split') {
                    if (!form.totalBill || parseFloat(form.totalBill) <= 0) {
                        alert('Please enter a valid total bill amount');
                        setLoading(false);
                        return;
                    }
                    if (selectedFriends.length === 0 && !includeMe) {
                        alert('Please select at least one participant');
                        setLoading(false);
                        return;
                    }
                    if (!isSplitValid) {
                        if (splitError) alert(splitError);
                        else alert(`Split total (${formatMoney(fromCents(sumSplitsCents))}) does not match bill amount (${formatMoney(fromCents(totalBillCents))}). Difference: ${formatMoney(fromCents(remainingCents))}`);
                        setLoading(false);
                        return;
                    }
                    if (!form.category || form.category.trim() === '') {
                        alert('Please enter a category');
                        setLoading(false);
                        return;
                    }
                    if (!form.date) {
                        alert('Please select a date');
                        setLoading(false);
                        return;
                    }
                }
                
                let body = {};
                const isUpdate = editItem && editItem.id;
               
                if(tab === 'split') {
                    const items = [];
                   
                    // Create Payer Share (Confirmed Expense)
                    if(includeMe && splitAmounts['me'] && parseFloat(splitAmounts['me']) > 0) {
                        items.push({
                            ...form,
                            type: 'expense',
                            amount: parseFloat(splitAmounts['me']),
                            description: `${form.description || 'Split Bill'} (My Share)`,
                            relatedPerson: '',
                            status: 'Confirmed', // Payer's share is immediately confirmed
                            paymentMode: form.paymentMode || 'Online',
                            date: form.date,
                            category: form.category || 'General'
                        });
                    }
                   
                    // Create Friend Shares (Friends owe me money - they borrowed from me)
                    selectedFriends.forEach(id => {
                        const splitAmt = splitAmounts[id];
                        if(splitAmt && parseFloat(splitAmt) > 0) {
                            const friend = people.find(p => p.id === id);
                            const statusForFriend = (friend && friend.email) ? 'Pending' : 'Confirmed'; // auto-confirm for manual friends (no email)
                            items.push({
                                ...form,
                                type: 'borrowed', // Friend borrowed from me
                                amount: parseFloat(splitAmt),
                                description: `${form.description || 'Split Bill'} (Split Bill with ${friend?.name || 'Friend'})`,
                                relatedPerson: id,
                                status: statusForFriend,
                                paymentMode: form.paymentMode || 'Online',
                                date: form.date,
                                category: form.category || 'General'
                            });
                        }
                    });
                   
                    if(items.length === 0) { 
                        alert("Invalid split: No valid amounts to split"); 
                        setLoading(false); 
                        return; 
                    }
                    body = { action: 'batchAdd', userId: user.id, items };
                } else {
                    // FINANCIAL CORRECTNESS: Set appropriate status based on transaction type
                    let status = 'Confirmed';
                    if (['lent', 'borrowed', 'repayment_in', 'repayment_out'].includes(form.type) && form.relatedPerson) {
                        const target = people.find(p => p.id === form.relatedPerson);
                        status = (target && target.email) ? 'Pending' : 'Confirmed'; // auto-confirm if friend is manual/unlinked
                    }
                    
                    // Validate amount is valid number
                    const amountValue = parseFloat(form.amount);
                    if (isNaN(amountValue) || amountValue <= 0) {
                        alert('Please enter a valid amount greater than 0');
                        setLoading(false);
                        return;
                    }
                    
                    body = { 
                        action: isUpdate ? 'update' : 'add', 
                        id: isUpdate ? editItem.id : undefined, 
                        userId: user.id, 
                        ...form,
                        amount: amountValue,
                        status: isUpdate ? (editItem.status || status) : status
                    };
                }
               
                try {
                    if (mutate) {
                        // Optimistic update for add/update
                        if (body.action === 'add') {
                            const tmpId = 'tmp_' + Date.now();
                            const tmpItem = { ...form, id: tmpId, userId: user.id, status: body.status || 'Confirmed', amount: body.amount };
                            // insert at top
                            setData(prev => ({ ...prev, transactions: [tmpItem, ...(prev.transactions || [])] }));
                            onClose();
                            try {
                                const json = await mutate(body, { skipFetch: true });
                                if (json && json.success === false) {
                                    // remove tmp
                                    setData(prev => ({ ...prev, transactions: (prev.transactions || []).filter(tr => tr.id !== tmpId) }));
                                    alert(json.error || 'Error saving transaction');
                                    setLoading(false);
                                } else {
                                    // optionally refresh in background
                                    if (fetchData && lastFetchParams !== undefined) {
                                        fetchData(lastFetchParams);
                                    }
                                    setLoading(false);
                                }
                            } catch (e) {
                                setData(prev => ({ ...prev, transactions: (prev.transactions || []).filter(tr => tr.id !== tmpId) }));
                                alert('Error saving transaction: ' + (e.message || 'Network error'));
                                setLoading(false);
                            }
                            return;
                        }
                        if (body.action === 'update') {
                            // optimistic update local item
                            const prevItem = (data && data.transactions) ? data.transactions.find(x => x.id === body.id) : null;
                            setData(prev => ({ 
                                ...prev, 
                                transactions: (prev.transactions || []).map(tr => tr.id === body.id ? { ...tr, ...body, amount: body.amount } : tr) 
                            }));
                            onClose();
                            try {
                                const json = await mutate(body, { skipFetch: true });
                                if (json && json.success === false) {
                                    // rollback
                                    if (prevItem) {
                                        setData(prev => ({ ...prev, transactions: (prev.transactions || []).map(tr => tr.id === body.id ? prevItem : tr) }));
                                    }
                                    alert(json.error || 'Error updating transaction');
                                    setLoading(false);
                                } else {
                                    if (fetchData && lastFetchParams !== undefined) {
                                        fetchData(lastFetchParams);
                                    }
                                    setLoading(false);
                                }
                            } catch (e) {
                                if (prevItem) {
                                    setData(prev => ({ ...prev, transactions: (prev.transactions || []).map(tr => tr.id === body.id ? prevItem : tr) }));
                                }
                                alert('Error updating transaction: ' + (e.message || 'Network error'));
                                setLoading(false);
                            }
                            return;
                        }

                        // Fallback: default mutate behavior (for batchAdd)
                        const json = await mutate(body);
                        if (json && json.success === false) { 
                            alert(json.error || 'Error saving transaction'); 
                            setLoading(false); 
                            return; 
                        }
                        onClose();
                        setLoading(false);
                    } else {
                        const res = await fetch(API_URL, { method: 'POST', body: JSON.stringify(body) });
                        const json = await res.json();
                        if (json && json.success === false) {
                            alert(json.error || 'Error saving transaction');
                            setLoading(false);
                            return;
                        }
                        onClose();
                        setLoading(false);
                    }
                } catch (error) {
                    console.error('Transaction save error:', error);
                    alert("Error saving transaction: " + (error.message || 'Please check your connection and try again'));
                    setLoading(false);
                }
            };
           
            const handleDelete = async () => { 
                if(!confirm("Delete this transaction? This will revert all financial effects.")) return; 
                // Optimistic local delete
                const backup = (data && data.transactions) ? [...data.transactions] : [];
                setData(prev => ({ ...prev, transactions: prev.transactions.filter(tr => tr.id !== editItem.id) }));
                onClose();
                try {
                    if (mutate) {
                        const json = await mutate({ action: 'delete', id: editItem.id, userId: user.id, revertBalances: true }, { skipFetch: true });
                        if (json && json.success === false) {
                            // rollback
                            setData(prev => ({ ...prev, transactions: backup }));
                            alert(json.error || 'Error deleting transaction');
                        } else {
                            fetchData(lastFetchParams);
                        }
                    } else {
                        await fetch(API_URL, { method: 'POST', body: JSON.stringify({ action: 'delete', id: editItem.id, userId: user.id, revertBalances: true }) });
                        fetchData(lastFetchParams);
                    }
                } catch (e) {
                    setData(prev => ({ ...prev, transactions: backup }));
                    alert('Error');
                }
            };
            
            // FIXED: Render split validation status
            const renderSplitValidation = () => {
                if (tab !== 'split') return null;

                if (splitError) {
                    return (
                        <div className="text-xs font-bold text-center p-2 rounded-lg bg-red-50 text-red-600">
                            {splitError}
                        </div>
                    );
                }

                const isValid = sumSplitsCents === totalBillCents;
                return (
                    <div className={`text-xs font-bold text-center p-2 rounded-lg ${isValid ? 'bg-emerald-50 text-emerald-600' : 'bg-red-50 text-red-600'}`}>
                        {isValid ? (
                            'âœ“ Split amounts match total bill'
                        ) : (
                            `âš ï¸ Difference: ${formatMoney(fromCents(Math.abs(remainingCents)))} ${remainingCents > 0 ? 'remaining' : 'over'}`
                        )}
                    </div>
                );
            };
            
            // FIXED: Load example for your scenario
            const loadExample = () => {
                setForm({...form, totalBill: '500'});
                setIncludeMe(false);
                // Select first 3 friends for example
                const exampleFriends = people.slice(0, 3).map(p => p.id);
                setSelectedFriends(exampleFriends);
                
                setTimeout(() => {
                    setSplitAmounts({
                        [exampleFriends[0]]: 50,
                        [exampleFriends[1]]: 225,
                        [exampleFriends[2]]: 225
                    });
                    setLockedAmounts({
                        [exampleFriends[0]]: true // Lock Friend A's amount
                    });
                }, 100);
            };
            
            // FIXED: Common categories with auto-suggest
            const commonCategories = [
                'Food', 'Transport', 'Housing', 'Utilities', 'Entertainment', 
                'Shopping', 'Healthcare', 'Education', 'Personal Care', 'Gifts',
                'Investment', 'Income', 'General'
            ];
            
            return (
                <div className="fixed inset-0 z-50 flex items-end justify-center bg-slate-900/60 backdrop-blur-sm p-2 sm:items-center">
                    <div className="bg-white dark:bg-slate-900 w-full max-w-md modal-inner shadow-2xl animate-up max-h-[90vh] overflow-y-auto">
                        <div className="flex justify-between items-center mb-6">
                            <h3 className="font-bold text-xl dark:text-white">{editItem && editItem.id ? 'Edit Entry' : 'New Entry'}</h3>
                            <button onClick={onClose}><i data-lucide="x" className="w-5 h-5 text-slate-400"></i></button>
                        </div>
                        {!editItem && (
                            <div className="flex p-1 bg-slate-100 dark:bg-slate-800 rounded-2xl mb-6">
                                {['simple', 'friend', 'split'].map(t => (
                                    <button key={t} onClick={()=>setTab(t)} className={`flex-1 py-3 text-xs font-bold uppercase tracking-wider rounded-xl transition-all ${tab===t?'bg-white dark:bg-slate-700 shadow ' + THEMES[theme].text :'text-slate-400'}`}>
                                        {t}
                                    </button>
                                ))}
                            </div>
                        )}
                        <form onSubmit={submit} className="space-y-5">
                            {tab === 'simple' && (
                                <>
                                    <div className="flex gap-3">
                                        <button type="button" onClick={()=>setForm({...form, type:'income'})} className={`flex-1 py-4 rounded-2xl border-2 font-bold transition-all ${form.type==='income'?'border-emerald-500 bg-emerald-50 text-emerald-600 dark:bg-emerald-900/20':'border-transparent bg-slate-50 dark:bg-slate-800 text-slate-500'}`}>
                                            Money In
                                        </button>
                                        <button type="button" onClick={()=>setForm({...form, type:'expense'})} className={`flex-1 py-4 rounded-2xl border-2 font-bold transition-all ${form.type==='expense'?'border-red-500 bg-red-50 text-red-600 dark:bg-red-900/20':'border-transparent bg-slate-50 dark:bg-slate-800 text-slate-500'}`}>
                                            Money Out
                                        </button>
                                    </div>
                                    <div className={`bg-slate-50 dark:bg-slate-800 p-4 rounded-2xl border ${THEMES[theme].border} border-opacity-20`}>
                                        <p className={`text-xs font-bold uppercase ${THEMES[theme].text} mb-2`}>Amount</p>
                                        <input 
                                            type="number" 
                                            min="0" 
                                            step="0.01" 
                                            placeholder="â‚¹0.00" 
                                            className={`w-full bg-transparent text-2xl font-bold outline-none ${THEMES[theme].text}`} 
                                            value={form.amount || ''} 
                                            onChange={e => setForm({...form, amount: e.target.value})} 
                                            required 
                                        />
                                    </div>
                                </>
                            )}
                            {tab === 'split' && (
                                <div className="space-y-4">
                                    <div className={`bg-slate-50 dark:bg-slate-800 p-4 rounded-2xl border ${THEMES[theme].border} border-opacity-20`}>
                                        <div className="flex justify-between items-center mb-2">
                                            <p className={`text-xs font-bold uppercase ${THEMES[theme].text}`}>Total Bill</p>
                                            <button type="button" onClick={loadExample} className="text-xs text-slate-500 hover:text-indigo-500">
                                                Load Example
                                            </button>
                                        </div>
                                        <input type="number" min="0" step="0.01" placeholder="â‚¹0" className={`w-full bg-transparent text-3xl font-bold outline-none ${THEMES[theme].text}`} value={form.totalBill} onChange={e => setForm({...form, totalBill: e.target.value})} />
                                    </div>
                                    
                                    {renderSplitValidation()}
                                    
                                    <div className="flex gap-2 mb-2">
                                        <button type="button" onClick={()=>setSplitMode('equal')} className={`flex-1 py-2 text-xs font-bold rounded-lg border ${splitMode==='equal'?THEMES[theme].border + ' ' + THEMES[theme].text :'border-slate-200 text-slate-400'}`}>
                                            Smart Split
                                        </button>
                                        <button type="button" onClick={()=>setSplitMode('custom')} className={`flex-1 py-2 text-xs font-bold rounded-lg border ${splitMode==='custom'?THEMES[theme].border + ' ' + THEMES[theme].text :'border-slate-200 text-slate-400'}`}>
                                            Custom Split
                                        </button>
                                    </div>
                                    
<div className="flex items-center gap-3 p-3 bg-slate-50 dark:bg-slate-800 rounded-xl">
    <div className={`w-5 h-5 rounded border flex items-center justify-center cursor-pointer ${includeMe ? THEMES[theme].class + ' border-transparent text-white' : 'border-slate-300'}`} onClick={()=>setIncludeMe(!includeMe)}>
        {includeMe && <i data-lucide="check" className="w-3 h-3"></i>}
    </div>
    <div className="flex-1 text-sm font-bold dark:text-white">Include Me (Payer)</div>
    {includeMe && (
        <div className="flex items-center gap-2">
            <button type="button" onClick={() => toggleLockAmount('me')} className={`p-1 rounded ${lockedAmounts['me'] ? 'bg-indigo-100 text-indigo-600' : 'text-slate-400'}`}>
                <i data-lucide={lockedAmounts['me'] ? "lock" : "unlock"} className="w-3 h-3"></i>
            </button>
            <input type="number" min="0" step="0.01" className="w-20 p-2 text-right bg-transparent outline-none font-bold" placeholder="0" value={splitAmounts['me'] || ''} onChange={e => handleCustomSplitChange('me', e.target.value)} />
        </div>
    )}
</div>
                                <div className="space-y-2 max-h-40 overflow-y-auto hide-scroll">
                                    {people.map(p => (
                                        <div key={p.id} className={`flex items-center gap-3 p-3 rounded-xl border transition-all ${selectedFriends.includes(p.id) ? THEMES[theme].border + ' bg-slate-50 dark:bg-slate-800' : 'border-slate-200 dark:border-slate-800'}`}>
                                            <div onClick={()=>toggleFriend(p.id)} className="cursor-pointer">
                                                <Avatar imageId={p.imageId} name={p.name} size="sm" theme={theme} />
                                            </div>
                                            <div className="flex-1 text-sm font-bold dark:text-white cursor-pointer" onClick={()=>toggleFriend(p.id)}>
                                                {p.name}
                                                {!p.email && <span className="text-[10px] text-slate-500 ml-1">(Manual)</span>}
                                            </div>
                                            {selectedFriends.includes(p.id) && (
                                                <div className="flex items-center gap-2">
                                                    <button type="button" onClick={() => toggleLockAmount(p.id)} className={`p-1 rounded ${lockedAmounts[p.id] ? 'bg-indigo-100 text-indigo-600' : 'text-slate-400'}`}>
                                                        <i data-lucide={lockedAmounts[p.id] ? "lock" : "unlock"} className="w-3 h-3"></i>
                                                    </button>
                                                    <input type="number" min="0" step="0.01" className="w-20 p-2 text-right bg-transparent outline-none font-bold" placeholder="0" value={splitAmounts[p.id] || ''} onChange={e => handleCustomSplitChange(p.id, e.target.value)} />
                                                </div>
                                            )}
                                        </div>
                                    ))}
                                </div>
                                
                                {/* Split summary */}
                                <div className="bg-slate-50 dark:bg-slate-800 p-3 rounded-xl">
                                    <div className="flex justify-between text-xs font-bold mb-1">
                                        <span className="text-slate-500">Participants:</span>
                                        <span>{selectedFriends.length + (includeMe ? 1 : 0)}</span>
                                    </div>
                                    <div className="flex justify-between text-xs font-bold mb-1">
                                        <span className="text-slate-500">Total Bill:</span>
                                        <span className={THEMES[theme].text}>{formatMoney(form.totalBill || 0)}</span>
                                    </div>
                                    <div className="flex justify-between text-xs font-bold">
                                        <span className="text-slate-500">Split Total:</span>
                                        <span className={isSplitValid ? 'text-emerald-600' : 'text-red-600'}>
                                            {formatMoney(fromCents(sumSplitsCents))}
                                        </span>
                                    </div>
                                </div>
                            </div>
                        )}
                        {tab === 'friend' && (
                            <>
                                <select className="input-field" value={form.type} onChange={e=>setForm({...form, type:e.target.value})} required>
                                    <option value="lent">Money Rented (I gave)</option>
                                    <option value="borrowed">Money Taken (I took)</option>
                                    <option value="repayment_in">He Paid Back</option>
                                    <option value="repayment_out">I Paid Back</option>
                                </select>
                                <div className={`bg-slate-50 dark:bg-slate-800 p-4 rounded-2xl border ${THEMES[theme].border} border-opacity-20`}>
                                    <p className={`text-xs font-bold uppercase ${THEMES[theme].text} mb-2`}>Amount</p>
                                    <input 
                                        type="number" 
                                        min="0" 
                                        step="0.01" 
                                        placeholder="â‚¹0.00" 
                                        className={`w-full bg-transparent text-2xl font-bold outline-none ${THEMES[theme].text}`} 
                                        value={form.amount || ''} 
                                        onChange={e => setForm({...form, amount: e.target.value})} 
                                        required 
                                    />
                                </div>
                                <div className="flex gap-4 overflow-x-auto pb-2 hide-scroll">
                                    {people.length === 0 ? (
                                        <p className="text-sm text-slate-400 text-center w-full py-4">No friends added yet. Add a friend first.</p>
                                    ) : (
                                        people.map(p => (
                                            <div key={p.id} onClick={()=>setForm({...form, relatedPerson: p.id})} className="flex flex-col items-center gap-2 cursor-pointer group">
                                                <Avatar imageId={p.imageId} name={p.name} theme={theme} />
                                                <span className={`text-[10px] font-bold ${form.relatedPerson === p.id ? THEMES[theme].text :'text-slate-500'}`}>{p.name}</span>
                                                {!p.email && <span className="text-[8px] text-slate-400">Manual</span>}
                                            </div>
                                        ))
                                    )}
                                </div>
                                {form.type && ['lent', 'borrowed', 'repayment_in', 'repayment_out'].includes(form.type) && !form.relatedPerson && (
                                    <p className="text-xs text-amber-600 dark:text-amber-400 font-bold">âš ï¸ Please select a friend</p>
                                )}
                            </>
                        )}
                        <div className="flex gap-2">
                            <button type="button" onClick={()=>setForm({...form, paymentMode:'Online'})} className={`flex-1 py-3 rounded-xl text-xs font-bold transition-all ${form.paymentMode==='Online'?THEMES[theme].class + ' text-white shadow-lg':'bg-slate-100 dark:bg-slate-800 dark:text-slate-400'}`}>Online</button>
                            <button type="button" onClick={()=>setForm({...form, paymentMode:'Cash'})} className={`flex-1 py-3 rounded-xl text-xs font-bold transition-all ${form.paymentMode==='Cash'?THEMES[theme].class + ' text-white shadow-lg':'bg-slate-100 dark:bg-slate-800 dark:text-slate-400'}`}>Cash</button>
                        </div>

                        {/* Reminder action (UX): shown beneath payment status and amount, separated from financial actions */}
                        {editItem && editItem.id && editItem.status === 'Pending' && (
                            <div className="mt-4 p-3 rounded-xl border bg-slate-50 dark:bg-slate-800 border-slate-200 dark:border-slate-700">
                                <>
                                    <button type="button" onClick={() => {
                                        // confirmation popup per spec with explicit button label
                                        const recipient = people.find(p=>p.id === (editItem.relatedPerson || form.relatedPerson));
                                        const name = recipient?.name || 'them';
                                        setDialog({
                                            isOpen: true,
                                            title: 'Send reminder?',
                                            msg: `This will notify ${name} that the payment of ${formatMoney(form.amount || editItem.amount || 0)} is still pending.\nNo payment will be processed automatically.`,
                                            onConfirm: async () => { setDialog({ isOpen: false }); await doSendReminder(); },
                                            onCancel: () => setDialog({ isOpen: false }),
                                            type: 'neutral',
                                            confirmLabel: 'Send reminder'
                                        });
                                    }} className={`w-full py-3 rounded-xl font-bold text-sm ${reminderSent ? 'bg-slate-100 text-slate-500' : THEMES[theme].class + ' text-white shadow-lg'}`}>
                                        {sendingReminder ? 'Sending...' : (reminderSent ? 'Send reminder again' : 'Send payment reminder')}
                                    </button>
                                    <div className="mt-2 text-xs text-slate-400">{reminderSent ? "Reminder sent" : "Reminds the other person about this pending payment"}</div>
                                    {reminderToast && (
                                        <div className="mt-3 p-2 rounded-lg bg-emerald-50 text-emerald-700 text-sm font-bold">
                                            <div>{reminderToast.title}</div>
                                            <div className="text-xs font-normal">{reminderToast.sub}</div>
                                        </div>
                                    )}
                                </>
                            </div>
                        )}
                        
                        {/* FIXED: Category input with suggestions */}
                        <div className="relative">
                            <input 
                                className="input-field" 
                                placeholder="Category (e.g., Food, Transport)" 
                                value={form.category || ''} 
                                onChange={e=>setForm({...form, category:e.target.value})} 
                                list="category-suggestions"
                                required 
                            />
                            <datalist id="category-suggestions">
                                {commonCategories.map(cat => (
                                    <option key={cat} value={cat} />
                                ))}
                                {/* Add common sub-categories that will be normalized */}
                                <option value="Egg" />
                                <option value="Chicken" />
                                <option value="Fuel" />
                                <option value="Uber" />
                                <option value="Movie" />
                                <option value="Netflix" />
                                <option value="Rent" />
                                <option value="Electricity" />
                            </datalist>
                            {form.category && (
                                <div className="absolute right-3 top-1/2 transform -translate-y-1/2 pointer-events-none">
                                    <span className="text-xs text-slate-400 bg-white dark:bg-slate-900 px-1 rounded">
                                        â†’ {normalizeCategory(form.category)}
                                    </span>
                                </div>
                            )}
                        </div>
                        
                        <textarea 
                            className="input-field" 
                            placeholder="Description (Optional)" 
                            value={form.description || ''} 
                            onChange={e=>setForm({...form, description:e.target.value})} 
                            rows="2" 
                        />
                        <label className="flex items-center gap-3 p-3 rounded-xl border border-dashed border-slate-300 dark:border-slate-700 cursor-pointer hover:bg-slate-50 dark:hover:bg-slate-800">
                            <div className={`w-10 h-10 rounded-full flex items-center justify-center bg-slate-100 text-slate-400`}>
                                <i data-lucide={form.imageBase64 ? 'check' : 'camera'}></i>
                            </div>
                            <span className="text-sm text-slate-500">{form.imageBase64 ? 'Receipt Attached' : 'Attach Receipt'}</span>
                            <input type="file" className="hidden" accept="image/*" onChange={handleImage} />
                        </label>
                        <div>
                            <label className="block text-xs font-bold text-slate-500 uppercase mb-2">Date</label>
                            <input 
                                className="input-field" 
                                type="date" 
                                value={form.date || ''} 
                                onChange={e=>setForm({...form, date:e.target.value})} 
                                required 
                                max={new Date().toISOString().split('T')[0]}
                            />
                        </div>
                        <button 
                            disabled={loading || (tab === 'split' && !isSplitValid)} 
                            className={`btn-primary shadow-xl text-lg ${THEMES[theme].class} ${(loading || (tab === 'split' && !isSplitValid)) ? 'opacity-50 cursor-not-allowed' : ''}`}
                        >
                            {loading ? 'Saving...' : (editItem && editItem.id ? 'Update' : 'Save')}
                        </button>
                        {editItem && editItem.id && (
                            <button type="button" onClick={handleDelete} className="w-full py-3 text-red-500 font-bold bg-red-50 dark:bg-red-900/20 rounded-xl">
                                Delete Entry
                            </button>
                        )}
                    </form>
                </div>
            </div>
        );
    }
    
    function PersonModal({ user, onClose, theme, mutate }) { 
        const [mode, setMode] = useState('search'); 
        const [query, setQuery] = useState(''); 
        const [results, setResults] = useState([]); 
        const [loading, setLoading] = useState(false); 
        const [manualForm, setManualForm] = useState({ name: '', phone: '', imageBase64: '' }); 
        
        const handleSearch = async (e) => { 
            e.preventDefault(); 
            setLoading(true); 
            try { 
                const res = await fetch(`${API_URL}?action=searchUsers&userId=${user.id}&query=${query}`); 
                const json = await res.json(); 
                if(json.success) setResults(json.results); 
            } catch(e) {} 
            setLoading(false); 
        }; 
        
        const connectUser = async (targetUser) => { 
            setLoading(true); 
            try {
                if (mutate) {
                    const json = await mutate({ action: 'addPerson', userId: user.id, linkedUserId: targetUser.id, name: targetUser.name });
                    if (json && json.success === false) { alert(json.error || 'Error'); }
                    else onClose();
                } else {
                    await fetch(API_URL, { method: 'POST', body: JSON.stringify({ action: 'addPerson', userId: user.id, linkedUserId: targetUser.id, name: targetUser.name }) });
                    onClose();
                }
            } catch (e) { alert('Error'); } finally { setLoading(false); }
        };
        
        const handleImage = (e) => { 
            const file = e.target.files[0]; 
            if(file) compressImage(file).then(b64 => setManualForm({...manualForm, imageBase64: b64})); 
        }; 
        
        const submitManual = async (e) => { 
            e.preventDefault(); 
            setLoading(true); 
            try {
                if (mutate) {
                    const json = await mutate({ action: 'addPerson', userId: user.id, ...manualForm });
                    if (json && json.success === false) { alert(json.error || 'Error'); }
                    else onClose();
                } else {
                    await fetch(API_URL, { method: 'POST', body: JSON.stringify({ action: 'addPerson', userId: user.id, ...manualForm }) });
                    onClose();
                }
            } catch(e) { alert('Error'); } finally { setLoading(false); }
        }; 
        
        return (
            <div className="fixed inset-0 z-50 flex items-center justify-center bg-slate-900/60 backdrop-blur-sm p-4">
                <div className="bg-white dark:bg-slate-900 w-full max-w-sm rounded-[2rem] p-6 animate-up shadow-2xl h-[500px] flex flex-col">
                    <div className="flex justify-between items-center mb-4">
                        <h3 className="font-bold text-lg dark:text-white">{mode==='search'?'Find Friend':'Add Manual Reminder'}</h3>
                        <button onClick={onClose}><i data-lucide="x" className="w-5 h-5 text-slate-400"></i></button>
                    </div>
                    {mode === 'search' ? (
                        <div className="flex-1 flex flex-col">
                            <form onSubmit={handleSearch} className="flex gap-2 mb-4">
                                <input className="input-field py-2" placeholder="Search by name..." value={query} onChange={e=>setQuery(e.target.value)} autoFocus />
                                <button className={`text-white p-3 rounded-xl ${THEMES[theme].class}`}><i data-lucide="search" className="w-5 h-5"></i></button>
                            </form>
                            <div className="flex-1 overflow-y-auto space-y-2 mb-4">
                                {results.map(r => (
                                    <div key={r.id} className="flex items-center justify-between p-3 bg-slate-50 dark:bg-slate-800 rounded-xl">
                                        <div className="flex items-center gap-3">
                                            <Avatar imageId={r.imageId} name={r.name} size="sm" theme={theme} />
                                            <span className="font-bold text-sm dark:text-white">{r.name}</span>
                                        </div>
                                        <button onClick={()=>connectUser(r)} disabled={loading} className={`text-xs px-3 py-1.5 rounded-lg font-bold bg-slate-100 ${THEMES[theme].text}`}>Connect</button>
                                    </div>
                                ))}
                            </div>
                            <div className="text-center pt-4 border-t border-slate-100 dark:border-slate-800">
                                <p className="text-xs text-slate-400 mb-2">Can't find them?</p>
                                <button onClick={()=>setMode('manual')} className="w-full py-3 bg-slate-100 dark:bg-slate-800 text-slate-600 dark:text-slate-300 font-bold rounded-xl text-sm">Add Manually (No Sync)</button>
                            </div>
                        </div>
                    ) : (
                        <form onSubmit={submitManual} className="flex-1 flex flex-col gap-4">
                            <label className="block w-20 h-20 mx-auto rounded-full bg-slate-100 dark:bg-slate-800 border-2 border-dashed border-slate-300 flex items-center justify-center overflow-hidden cursor-pointer hover:bg-slate-200 transition">
                                {manualForm.imageBase64 ? <img src={manualForm.imageBase64} className="w-full h-full object-cover"/> : <i data-lucide="camera" className="text-slate-400 w-6 h-6"></i>}
                                <input type="file" className="hidden" accept="image/*" onChange={handleImage} />
                            </label>
                            <input className="input-field" placeholder="Name" value={manualForm.name} onChange={e=>setManualForm({...manualForm, name:e.target.value})} required />
                            <input className="input-field" placeholder="Phone (Optional)" value={manualForm.phone} onChange={e=>setManualForm({...manualForm, phone:e.target.value})} />
                            <div className="mt-auto flex gap-3">
                                <button type="button" onClick={()=>setMode('search')} className="flex-1 py-3 text-slate-500 font-bold">Back</button>
                                <button disabled={loading} className={`flex-1 btn-primary shadow-lg ${THEMES[theme].class}`}>{loading ? '...' : 'Save'}</button>
                            </div>
                        </form>
                    )}
                </div>
            </div>
        ); 
    }
    
    function ProfileView({ user, onUpdate, theme, setTheme, setAccentColor, mutate }) { 
        const [form, setForm] = useState({ username: user.name, phone: user.phone, imageBase64: '' }); 
        const [loading, setLoading] = useState(false); 
        
        const handleImage = (e) => { 
            const file = e.target.files[0]; 
            if(file) compressImage(file).then(b64 => setForm({...form, imageBase64: b64})); 
        }; 
        
        const save = async () => {
            setLoading(true);
            try {
                if (mutate) {
                    const json = await mutate({ action: 'updateProfile', userId: user.id, ...form });
                    if (json && json.success) {
                        const newUser = { ...user, name: form.username, phone: form.phone };
                        if (json.imageId) newUser.imageId = json.imageId;
                        onUpdate(newUser);
                        alert('Updated!');
                    } else {
                        alert(json?.error || 'Error');
                    }
                } else {
                    const res = await fetch(API_URL, { method: 'POST', body: JSON.stringify({ action: 'updateProfile', userId: user.id, ...form }) });
                    const json = await res.json();
                    if (json && json.success) {
                        const newUser = { ...user, name: form.username, phone: form.phone };
                        if (json.imageId) newUser.imageId = json.imageId;
                        onUpdate(newUser);
                        alert('Updated!');
                    } else {
                        alert(json?.error || 'Error');
                    }
                }
            } catch (e) { alert('Error'); }
            setLoading(false);
        };
        
        return (
            <div className="animate-fade space-y-8 p-2">
                <div className="flex flex-col items-center">
                    <label className="relative cursor-pointer group">
                        <Avatar imageId={user.imageId} name={user.name} size="lg" theme={theme} />
                        <div className={`absolute bottom-0 right-0 rounded-full p-1 text-white ${THEMES[theme].class}`}>
                            <i data-lucide="camera" className="w-4 h-4"></i>
                        </div>
                        <input type="file" className="hidden" accept="image/*" onChange={handleImage} />
                    </label>
                    <p className="mt-4 text-sm text-slate-400 font-bold">{user.email}</p>
                </div>
                <input className="input-field" value={form.username} onChange={e=>setForm({...form, username:e.target.value})} placeholder="Name" />
                <input className="input-field" value={form.phone} onChange={e=>setForm({...form, phone:e.target.value})} placeholder="Phone" />
                <button onClick={save} disabled={loading} className={`btn-primary shadow-lg ${THEMES[theme].class}`}>{loading?'...':'Update'}</button>
            </div>
        ); 
    }
    
    function Auth({ onLogin }) { 
        const [view, setView] = useState('login'); 
        const [form, setForm] = useState({ email: '', password: '', username: '', phone: '' }); 
        const [loading, setLoading] = useState(false); 
        const [msg, setMsg] = useState(null); 
        
        const submit = async (e) => { 
            e.preventDefault(); 
            setLoading(true); 
            setMsg(null); 
            try { 
                const url = view === 'login' ? `${API_URL}?action=login&email=${form.email}&password=${form.password}` : API_URL; 
                const opts = view === 'login' ? {} : { method: 'POST', body: JSON.stringify({ action: view, ...form }) }; 
                const res = await fetch(url, opts); 
                const json = await res.json(); 
                if(json.success) { 
                    if(view === 'login') onLogin(json.user); 
                    else { setMsg({type:'s', text:'Success! Login now.'}); setView('login'); } 
                } else setMsg({type:'e', text: json.error}); 
            } catch(e) { setMsg({type:'e', text: "Connection Error"}); } 
            setLoading(false); 
        }; 
        
        return (
            <div className="h-full flex items-center justify-center p-6 bg-slate-100 dark:bg-slate-900">
                <div className="w-full max-w-sm bg-white dark:bg-slate-950 p-8 rounded-[2rem] shadow-2xl animate-up">
                    <h1 className="text-3xl font-bold text-center mb-2">FinanceMax</h1>
                    {msg && <div className={`p-3 rounded-xl text-center text-sm mb-4 font-bold ${msg.type==='e'?'bg-red-50 text-red-500':'bg-emerald-50 text-emerald-600'}`}>{msg.text}</div>}
                    <form onSubmit={submit} className="space-y-4 mt-6">
                        {view==='signup' && (
                            <>
                                <input className="input-field" placeholder="Username" value={form.username} onChange={e=>setForm({...form, username:e.target.value})} required />
                                <input className="input-field" placeholder="Phone" value={form.phone} onChange={e=>setForm({...form, phone:e.target.value})} />
                            </>
                        )}
                        <input className="input-field" placeholder="Email" type="email" value={form.email} onChange={e=>setForm({...form, email:e.target.value})} required />
                        <input type="password" className="input-field" placeholder="Password" value={form.password} onChange={e=>setForm({...form, password:e.target.value})} required />
                        <button disabled={loading} className="btn-primary bg-indigo-600 shadow-xl shadow-indigo-500/30">
                            {loading ? <div className="loader mx-auto"></div> : (view==='login'?'Login':'Sign Up')}
                        </button>
                    </form>
                    <button onClick={()=>setView(view==='login'?'signup':'login')} className="w-full mt-6 text-sm text-slate-400 hover:text-indigo-500">
                        {view==='login'?'Create Account':'Back to Login'}
                    </button>
                </div>
            </div>
        ); 
    }
    
// Small responsive CSS helpers for modal and status icons
        const globalResponsiveStyles = `
            .modal-inner { border-radius: 1.25rem; padding: 1.25rem; }
            .confirm-buttons { display: flex; gap: .75rem; }
            .confirm-buttons.stack-on-mobile { display: flex; gap: .75rem; }
            @media (max-width: 520px) {
                .modal-inner { padding: .9rem; border-radius: 1rem; max-width: 94%; }
                .confirm-buttons.stack-on-mobile { flex-direction: column; }
            }
            .wrap-break { white-space: pre-wrap; word-break: break-word; }
            .status-icon-inline { display:inline-flex; width:1.5rem; height:1.5rem; min-width:1.5rem; align-items:center; justify-content:center; border-radius:9999px; }
            .status-icon-small { display:inline-flex; width:1rem; height:1rem; min-width:1rem; align-items:center; justify-content:center; border-radius:9999px; }

            /* Hide horizontal scrollbar visually but keep scrolling functional */
            .scroll-x { overflow-x: auto; overflow-y: hidden; -webkit-overflow-scrolling: touch; -ms-overflow-style: none; scrollbar-width: none; padding-bottom: 6px; }
            .scroll-x::-webkit-scrollbar { display: none; height: 0; }
            .scroll-x > * { display: inline-flex; }

            .theme-swatches { display:flex; gap:.5rem; align-items:center; }
            .swatch { box-sizing: border-box; flex-shrink:0; }
            .theme-row { gap: .75rem; }
            @media (max-width:520px) { .theme-swatches { gap:.5rem; } }
        `;
        if (!document.getElementById('fm-responsive-styles')) {
            const s = document.createElement('style');
            s.id = 'fm-responsive-styles';
            s.innerText = globalResponsiveStyles;
            document.head.appendChild(s);
        }

        function App() { 
        const [user, setUser] = useState(null); 
        useEffect(() => { 
            const saved = localStorage.getItem('fm_plat_user'); 
            if(saved) setUser(JSON.parse(saved)); 
        }, []); 
        
        const handleLogin = (u) => { 
            setUser(u); 
            localStorage.setItem('fm_plat_user', JSON.stringify(u)); 
        }; 
        
        const handleLogout = () => { 
            setUser(null); 
            localStorage.removeItem('fm_plat_user'); 
        }; 
        
        return user ? <Dashboard user={user} onLogout={handleLogout} /> : <Auth onLogin={handleLogin} />; 
    }
    
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>
</body>
</html><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>FinanceMax Platinum | Financial Systems Edition</title>
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#0f172a">
   
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: { slate: { 850: '#1e293b', 900: '#0f172a', 950: '#020617' } },
                    animation: { 'fade': 'fadeIn 0.2s ease-out', 'up': 'slideUp 0.3s cubic-bezier(0.16, 1, 0.3, 1)', 'spin-once': 'spin 0.5s linear' },
                    keyframes: {
                        fadeIn: { '0%': {opacity:0}, '100%': {opacity:1} },
                        slideUp: { '0%': {transform:'translateY(20px)', opacity:0}, '100%': {transform:'translateY(0)', opacity:1} }
                    }
                }
            }
        }
    </script>
   
    <style>
        body { -webkit-tap-highlight-color: transparent; overscroll-behavior-y: none; }
        .hide-scroll::-webkit-scrollbar { display: none; }
        .glass { background: rgba(255, 255, 255, 0.05); backdrop-filter: blur(12px); border: 1px solid rgba(255,255,255,0.1); }
        .dark .glass { background: rgba(15, 23, 42, 0.6); }
        .loader { width: 20px; height: 20px; border: 2px solid #fff; border-bottom-color: transparent; border-radius: 50%; animation: spin 0.8s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .input-field { width: 100%; padding: 1rem; border-radius: 1rem; background-color: #f8fafc; outline: none; border: 1px solid transparent; transition: all 0.2s; }
        .dark .input-field { background-color: #1e293b; color: white; }
        .input-field:focus { box-shadow: 0 0 0 2px var(--theme-color, #6366f1); background-color: white; }
        .dark .input-field:focus { background-color: #0f172a; }
        .btn-primary { color: white; font-weight: bold; border-radius: 1rem; padding: 1rem; transition: transform 0.1s; width: 100%; }
        .btn-primary:active { transform: scale(0.98); }
        .icon-btn { padding: 0.5rem; border-radius: 9999px; background-color: #f1f5f9; color: #64748b; transition: all; }
        .dark .icon-btn { background-color: #1e293b; color: #94a3b8; }
        .pb-safe { padding-bottom: env(safe-area-inset-bottom); }
        .scroll-x { overflow-x: auto; white-space: nowrap; -webkit-overflow-scrolling: touch; }
        /* Financial state indicators */
        .state-pending { background-color: #fef3c7; color: #92400e; border-color: #fbbf24; }
        .dark .state-pending { background-color: #78350f; color: #fbbf24; }
        .state-approved { background-color: #d1fae5; color: #065f46; border-color: #10b981; }
        .dark .state-approved { background-color: #064e3b; color: #10b981; }
        .state-paid { background-color: #dbeafe; color: #1e40af; border-color: #3b82f6; }
        .dark .state-paid { background-color: #1e3a8a; color: #60a5fa; }
        .state-confirmed { background-color: #dcfce7; color: #166534; border-color: #22c55e; }
        .dark .state-confirmed { background-color: #14532d; color: #4ade80; }
        .state-rejected { background-color: #fee2e2; color: #991b1b; border-color: #ef4444; }
        .dark .state-rejected { background-color: #7f1d1d; color: #f87171; }

        /* Responsive modal helper classes */
        .modal-inner { max-width: calc(100% - 32px); box-sizing: border-box; padding: 1rem; border-radius: 1rem; }
        @media (min-width: 640px) { .modal-inner { max-width: 28rem; padding: 1.5rem; border-radius: 2rem; } }
        .wrap-break { word-break: break-word; overflow-wrap: anywhere; }
        .confirm-buttons { display: flex; gap: 0.75rem; }
        @media (max-width: 639px) { .confirm-buttons { flex-direction: column; } }
        /* Make inputs a bit tighter on small screens */
        .input-field { padding: 0.75rem; }
        @media (min-width: 640px) { .input-field { padding: 1rem; } }
    </style>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/prop-types/prop-types.min.js"></script>
    <script src="https://unpkg.com/recharts@2.10.3/umd/Recharts.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
</head>
<body class="bg-slate-50 text-slate-900 dark:bg-slate-950 dark:text-slate-100 transition-colors duration-300 font-sans h-screen w-screen overflow-hidden">
    <div id="root" class="h-full w-full"></div>
    <script type="text/babel">
        const API_URL = "https://script.google.com/macros/s/AKfycbx0L7jO5pGLNUKWk5k1GebDpWuZLuaG7DDZVGslvNBR2l_gsSoRg02kj0LN1R8j5w/exec";
        const { useState, useEffect, useMemo, useRef } = React;
        const { AreaChart, Area, BarChart, Bar, PieChart, Pie, Cell, ResponsiveContainer, Tooltip, XAxis, Legend } = window.Recharts || {};
        const COLORS = ['#6366f1', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899'];
       
        // FINANCIAL ENGINE CORE UTILS - ENHANCED FOR CENT-PRECISION
        const toCents = (val) => Math.round(parseFloat(val || 0) * 100);
        const fromCents = (val) => Number((val / 100).toFixed(2));
        const formatMoney = (val) => new Intl.NumberFormat('en-IN', { style: 'currency', currency: 'INR', minimumFractionDigits: 2 }).format(val || 0);
        
        // ENHANCED: Smart split calculation with fixed amounts support
        const calculateSmartSplit = (totalCents, participants, fixedAmounts = {}) => {
            // Ensure fixedAmounts respects zero values and uses numeric semantics
            const result = {};
            let fixedTotalCents = 0;

            participants.forEach(id => {
                if (Object.prototype.hasOwnProperty.call(fixedAmounts, id)) {
                    const raw = fixedAmounts[id];
                    const num = Number(raw) || 0;
                    const cents = toCents(num);
                    fixedTotalCents += cents;
                    result[id] = fromCents(cents);
                }
            });

            if (fixedTotalCents > totalCents) {
                return { error: `Manual amounts exceed total by ${formatMoney(fromCents(fixedTotalCents - totalCents))}` };
            }

            const remainingCents = totalCents - fixedTotalCents;
            const remainingParticipants = participants.filter(id => !Object.prototype.hasOwnProperty.call(fixedAmounts, id));

            if (remainingParticipants.length === 0) {
                return result; // all fixed, already validated
            }

            const share = Math.floor(remainingCents / remainingParticipants.length);
            const remainder = remainingCents - (share * remainingParticipants.length);

            remainingParticipants.forEach((id, idx) => {
                const cents = share + (idx === remainingParticipants.length - 1 ? remainder : 0);
                result[id] = fromCents(cents);
            });

            return result;
        };
        
        // FINANCIAL CORRECTNESS: Split amount calculation with remainder absorption
        const calculateEqualSplit = (totalCents, count, payerIndex = 0) => {
            if (count <= 0) return [];
            const shareCents = Math.floor(totalCents / count);
            const remainderCents = totalCents - (shareCents * count);
            const shares = new Array(count).fill(shareCents);
            // FINANCIAL RULE: Remainder always absorbed by payer (index 0 = "Me")
            if (remainderCents > 0 && payerIndex >= 0 && payerIndex < count) {
                shares[payerIndex] += remainderCents;
            }
            return shares.map(cents => fromCents(cents));
        };
        
        // FINANCIAL CORRECTNESS: Validate split sum equals total with cent precision
        const validateSplitSum = (splitAmounts, totalCents) => {
            const sumCents = Object.values(splitAmounts).reduce((sum, val) => 
                sum + toCents(val), 0);
            // Invariant: the split must exactly equal the total in cents (no silent tolerance)
            return sumCents === totalCents;
        };
        
        // FINANCIAL STATE MACHINE: Define allowed transitions
        const ALLOWED_TRANSITIONS = {
            'Pending': ['Approved', 'Rejected', 'Deleted'],
            'Approved': ['Marked as Paid', 'Rejected', 'Deleted'],
            'Marked as Paid': ['Confirmed', 'Not Received', 'Deleted'],
            'Confirmed': ['Deleted'], // Only deletion with rollback allowed
            'Rejected': ['Deleted'], // Only deletion allowed
            'Not Received': ['Approved', 'Deleted'] // Go back to approved if not received
        };
        
        // FINANCIAL CORRECTNESS: Validate state transition
        const isValidTransition = (currentState, nextState) => {
            const allowed = ALLOWED_TRANSITIONS[currentState] || [];
            return allowed.includes(nextState);
        };
        
        // FINANCIAL CORRECTNESS: Balance mutation only allowed for Confirmed transactions
        const canMutateBalances = (status) => {
            return status === 'Confirmed';
        };
        
        // FINANCIAL CORRECTNESS: Check if transaction already processed for balances
        const createTransactionHash = (transaction) => {
            return `${transaction.id}_${transaction.status}_${transaction.amount}_${transaction.type}_${transaction.userId}`;
        };
        
        // ENHANCED CATEGORY NORMALIZATION SYSTEM
        const normalizeCategory = (category) => {
            if (!category || typeof category !== 'string') return 'Other';
            
            const normalized = category.toLowerCase().trim();
            
            // Comprehensive category mapping
            const categoryMap = {
                // FOOD & DINING
                'egg': 'Food', 'eggs': 'Food', 'chicken': 'Food', 'mutton': 'Food', 'fish': 'Food',
                'lunch': 'Food', 'dinner': 'Food', 'breakfast': 'Food', 'meal': 'Food', 'food': 'Food',
                'groceries': 'Food', 'vegetables': 'Food', 'fruits': 'Food', 'milk': 'Food',
                'restaurant': 'Food', 'cafe': 'Food', 'coffee': 'Food', 'tea': 'Food',
                'snacks': 'Food', 'chocolate': 'Food', 'biscuit': 'Food', 'cookies': 'Food',
                'pizza': 'Food', 'burger': 'Food', 'sandwich': 'Food', 'noodles': 'Food',
                'rice': 'Food', 'dal': 'Food', 'curry': 'Food', 'sabji': 'Food',
                'sweets': 'Food', 'ice cream': 'Food', 'dessert': 'Food',
                
                // TRANSPORT
                'fuel': 'Transport', 'petrol': 'Transport', 'diesel': 'Transport', 'gas': 'Transport',
                'uber': 'Transport', 'ola': 'Transport', 'rapido': 'Transport', 'taxi': 'Transport',
                'auto': 'Transport', 'rickshaw': 'Transport', 'bus': 'Transport', 'train': 'Transport',
                'metro': 'Transport', 'flight': 'Transport', 'travel': 'Transport',
                'parking': 'Transport', 'toll': 'Transport', 'maintenance': 'Transport',
                
                // HOUSING & UTILITIES
                'rent': 'Housing', 'emi': 'Housing', 'mortgage': 'Housing',
                'electricity': 'Utilities', 'water': 'Utilities', 'gas bill': 'Utilities',
                'internet': 'Utilities', 'wifi': 'Utilities', 'broadband': 'Utilities',
                'mobile': 'Utilities', 'phone': 'Utilities', 'recharge': 'Utilities',
                
                // ENTERTAINMENT
                'movie': 'Entertainment', 'netflix': 'Entertainment', 'prime': 'Entertainment',
                'hotstar': 'Entertainment', 'youtube': 'Entertainment', 'spotify': 'Entertainment',
                'concert': 'Entertainment', 'game': 'Entertainment', 'gaming': 'Entertainment',
                'outing': 'Entertainment', 'party': 'Entertainment', 'alcohol': 'Entertainment',
                'drinks': 'Entertainment', 'bar': 'Entertainment',
                
                // SHOPPING
                'shopping': 'Shopping', 'clothes': 'Shopping', 'shoes': 'Shopping',
                'electronics': 'Shopping', 'phone': 'Shopping', 'laptop': 'Shopping',
                'accessories': 'Shopping', 'watch': 'Shopping', 'jewelry': 'Shopping',
                'cosmetics': 'Shopping', 'makeup': 'Shopping', 'skincare': 'Shopping',
                
                // HEALTHCARE
                'medical': 'Healthcare', 'hospital': 'Healthcare', 'doctor': 'Healthcare',
                'medicine': 'Healthcare', 'pharmacy': 'Healthcare', 'test': 'Healthcare',
                'insurance': 'Healthcare', 'gym': 'Healthcare', 'fitness': 'Healthcare',
                'yoga': 'Healthcare',
                
                // EDUCATION
                'education': 'Education', 'books': 'Education', 'course': 'Education',
                'tuition': 'Education', 'school': 'Education', 'college': 'Education',
                'stationery': 'Education',
                
                // PERSONAL CARE
                'salon': 'Personal Care', 'haircut': 'Personal Care', 'spa': 'Personal Care',
                'massage': 'Personal Care', 'grooming': 'Personal Care',
                
                // GIFTS & DONATIONS
                'gift': 'Gifts', 'donation': 'Gifts', 'charity': 'Gifts',
                
                // INVESTMENTS
                'investment': 'Investment', 'stocks': 'Investment', 'mutual fund': 'Investment',
                'sip': 'Investment', 'fd': 'Investment', 'gold': 'Investment',
                
                // INCOME
                'salary': 'Income', 'freelance': 'Income', 'business': 'Income',
                'refund': 'Income', 'interest': 'Income', 'dividend': 'Income',
                
                // DEFAULT CATEGORIES
                'general': 'General', 'other': 'Other', 'misc': 'Other', 'miscellaneous': 'Other'
            };
            
            // Check exact matches first
            if (categoryMap[normalized]) {
                return categoryMap[normalized];
            }
            
            // Check for partial matches
            for (const [key, value] of Object.entries(categoryMap)) {
                if (normalized.includes(key) || key.includes(normalized)) {
                    return value;
                }
            }
            
            // If category contains food-related words
            const foodKeywords = ['egg', 'chicken', 'mutton', 'fish', 'rice', 'dal', 'curry', 'vegetable', 'fruit', 'milk'];
            if (foodKeywords.some(keyword => normalized.includes(keyword))) {
                return 'Food';
            }
            
            // If category contains transport-related words
            const transportKeywords = ['fuel', 'petrol', 'diesel', 'uber', 'ola', 'taxi', 'bus', 'train'];
            if (transportKeywords.some(keyword => normalized.includes(keyword))) {
                return 'Transport';
            }
            
            return category.charAt(0).toUpperCase() + category.slice(1); // Capitalize first letter
        };
        
        const compressImage = (file) => new Promise((resolve) => {
            const reader = new FileReader(); reader.readAsDataURL(file);
            reader.onload = (e) => { const img = new Image(); img.src = e.target.result; img.onload = () => { const canvas = document.createElement('canvas'); const scale = 600 / img.width; canvas.width = 600; canvas.height = img.height * scale; const ctx = canvas.getContext('2d'); ctx.drawImage(img, 0, 0, canvas.width, canvas.height); resolve(canvas.toDataURL('image/jpeg', 0.6)); }; };
        });
        // A palette of theme templates (16 options). Each has a primary color and Tailwind class hints.
        const THEMES = {
            indigo:  { bg: '#6366f1', class: 'bg-indigo-600',  text: 'text-indigo-600',  border: 'border-indigo-600' },
            emerald: { bg: '#10b981', class: 'bg-emerald-600', text: 'text-emerald-600', border: 'border-emerald-600' },
            rose:    { bg: '#e11d48', class: 'bg-rose-600',    text: 'text-rose-600',    border: 'border-rose-600' },
            amber:   { bg: '#f59e0b', class: 'bg-amber-600',   text: 'text-amber-600',   border: 'border-amber-600' },
            cyan:    { bg: '#06b6d4', class: 'bg-cyan-600',    text: 'text-cyan-600',    border: 'border-cyan-600' },
            teal:    { bg: '#14b8a6', class: 'bg-teal-600',    text: 'text-teal-600',    border: 'border-teal-600' },
            violet:  { bg: '#8b5cf6', class: 'bg-violet-600',  text: 'text-violet-600',  border: 'border-violet-600' },
            fuchsia: { bg: '#d946ef', class: 'bg-fuchsia-600', text: 'text-fuchsia-600', border: 'border-fuchsia-600' },
            pink:    { bg: '#ec4899', class: 'bg-pink-600',    text: 'text-pink-600',    border: 'border-pink-600' },
            lime:    { bg: '#84cc16', class: 'bg-lime-600',    text: 'text-lime-600',    border: 'border-lime-600' },
            yellow:  { bg: '#f59e0b', class: 'bg-yellow-500',  text: 'text-yellow-500',  border: 'border-yellow-500' },
            orange:  { bg: '#fb923c', class: 'bg-orange-500',  text: 'text-orange-500',  border: 'border-orange-500' },
            blue:    { bg: '#3b82f6', class: 'bg-blue-600',    text: 'text-blue-600',    border: 'border-blue-600' },
            gray:    { bg: '#6b7280', class: 'bg-gray-600',    text: 'text-gray-600',    border: 'border-gray-600' },
            slate:   { bg: '#0f172a', class: 'bg-slate-900',   text: 'text-slate-900',   border: 'border-slate-900' },
            sky:     { bg: '#0ea5e9', class: 'bg-sky-600',     text: 'text-sky-600',     border: 'border-sky-600' }
        };
        function Avatar({ imageId, name, size="md", theme }) {
            const [err, setErr] = useState(false);
            const dims = size==='lg'?'w-24 h-24 text-4xl':size==='sm'?'w-8 h-8 text-xs':'w-12 h-12 text-base';
            const url = imageId ? `https://drive.google.com/thumbnail?id=${imageId}&sz=w400` : null;
            const borderColor = (THEMES[theme] && THEMES[theme].bg) || '#cbd5e1';
            return <div className={`shrink-0 rounded-full flex items-center justify-center overflow-hidden ${dims} ${(!url || err) && 'bg-slate-100 dark:bg-slate-800'}`} style={{color: THEMES[theme] ? THEMES[theme].bg : undefined, borderColor: borderColor, borderStyle: 'solid', borderWidth: '1px'}}>{url && !err ? <img loading="lazy" src={url} className="w-full h-full object-cover" onError={()=>setErr(true)}/> : <span className="font-bold">{name?name[0].toUpperCase():'?'}</span>}</div>;
        }
        function ConfirmDialog({ isOpen, title, msg, onConfirm, onCancel, type='neutral', theme, single=false, confirmLabel='Confirm' }) {
            if(!isOpen) return null;
            const isDanger = type === 'danger';
            const iconBgStyle = isDanger ? { backgroundColor: '#fee2e2', color: '#ef4444' } : { backgroundColor: `${THEMES[theme].bg}20`, color: THEMES[theme].bg };
            const confirmBtnClass = isDanger ? 'bg-red-500 shadow-red-500/30' : `${THEMES[theme].class} shadow-lg`;
            return (
                <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 animate-fade">
                    <div className="absolute inset-0 bg-slate-900/60 backdrop-blur-md" onClick={onCancel}></div>
                    <div className="relative bg-white dark:bg-slate-900 w-full max-w-xs modal-inner shadow-2xl border border-slate-100 dark:border-slate-800 animate-up">
                        <div className="w-16 h-16 rounded-full flex items-center justify-center mx-auto mb-5" style={iconBgStyle}>
                            <i data-lucide={isDanger ? 'alert-triangle' : 'help-circle'} className="w-8 h-8"></i>
                        </div>
                        <h3 className="font-bold text-xl dark:text-white mb-2 text-center">{title}</h3>
                        <p className="text-slate-500 dark:text-slate-400 text-sm mb-8 text-center leading-relaxed wrap-break">{msg}</p>
                        <div className="confirm-buttons stack-on-mobile">
                            {!single && <button onClick={onCancel} className="flex-1 py-3.5 rounded-2xl bg-slate-100 dark:bg-slate-800 text-slate-600 dark:text-slate-300 font-bold text-sm hover:bg-slate-200 dark:hover:bg-slate-700 transition-colors">Cancel</button>}
                            <button onClick={onConfirm} className={`flex-1 py-3.5 rounded-2xl font-bold text-sm text-white shadow-xl active:scale-95 transition-transform ${confirmBtnClass}`}>{confirmLabel}</button>
                        </div>
                    </div>
                </div>
            );
        }
        
        // FINANCIAL CORRECTNESS: Transaction State Component
        function TransactionStateBadge({ status, theme, iconOnly=false, small=false }) {
            // Visual mapping (non-destructive)
            const stateConfig = {
                'Pending': { label: 'Pending', icon: 'clock', bg: 'bg-amber-100', fg: 'text-amber-600' },
                'Approved': { label: 'Approved', icon: 'check-circle', bg: 'bg-emerald-50', fg: 'text-emerald-600' },
                'Marked as Paid': { label: 'Paid', icon: 'check-circle', bg: 'bg-emerald-50', fg: 'text-emerald-600' },
                'Confirmed': { label: 'Confirmed', icon: 'check-circle', bg: 'bg-emerald-50', fg: 'text-emerald-600' },
                'Rejected': { label: 'Rejected', icon: 'x-circle', bg: 'bg-red-50', fg: 'text-red-600' },
                'Not Received': { label: 'Not Received', icon: 'alert-circle', bg: 'bg-red-50', fg: 'text-red-600' }
            };

            const config = stateConfig[status] || { label: status, icon: 'help-circle', bg: 'bg-slate-100', fg: 'text-slate-600' };

            if (iconOnly) {
                // Small variant: minimal, no background (keeps layout compact)
                if (small) {
                    return (
                        <span title={config.label} className={`status-icon-small ${config.fg}`} role="img" aria-label={config.label}>
                            <i data-lucide={config.icon} className="w-3 h-3"></i>
                        </span>
                    );
                }

                // Icon-only compact badge: subtle background and consistent size
                return (
                    <span title={config.label} className={`status-icon-inline ${config.bg} ${config.fg}`} role="img" aria-label={config.label}>
                        <i data-lucide={config.icon} className="w-4 h-4"></i>
                    </span>
                );
            }

            return (
                <span className={`inline-flex items-center gap-1 px-2 py-1 rounded-full text-[10px] font-bold uppercase ${config.bg} ${config.fg}`}>
                    <i data-lucide={config.icon} className="w-3 h-3"></i>
                    {config.label}
                </span>
            );
               
        }
        
        function Dashboard({ user, onLogout }) {
            const [data, setData] = useState({ transactions: [], people: [] });
            const [view, setView] = useState('home');
            const [modal, setModal] = useState(null);
            const [editItem, setEditItem] = useState(null);
            const [selectedFriend, setSelectedFriend] = useState(null);
            const [rejectedItems, setRejectedItems] = useState([]);
            const [dialog, setDialog] = useState({ isOpen: false });
            const [darkMode, setDarkMode] = useState(true);
            const [currentUser, setCurrentUser] = useState(user);
            const [loading, setLoading] = useState(false);
            const [refreshing, setRefreshing] = useState(false);
            const [filterDays, setFilterDays] = useState('TODAY');
            const [customN, setCustomN] = useState('');
            const [searchTerm, setSearchTerm] = useState('');
            const [activeGraph, setActiveGraph] = useState('trend');
            const [dateFrom, setDateFrom] = useState(null);
            const [dateTo, setDateTo] = useState(null);
            const [filterType, setFilterType] = useState('ALL'); // ALL, INCOMING, OUTGOING, REPAYMENT, LENT, BORROWED
            const [theme, setTheme] = useState(localStorage.getItem('fm_theme') || 'indigo');
            const [accentColor, setAccentColor] = useState(localStorage.getItem('fm_accent') || THEMES[localStorage.getItem('fm_theme') || 'indigo'].bg);
            const [budget, setBudget] = useState(localStorage.getItem('fm_budget') || '0');
            const [isCalendarMode, setIsCalendarMode] = useState(false);
            const [selectedDate, setSelectedDate] = useState(new Date().toISOString().split('T')[0]);
            const [calMonth, setCalMonth] = useState(new Date().getMonth());
            const [calYear, setCalYear] = useState(new Date().getFullYear());
            
            useEffect(() => {
                if(darkMode) document.documentElement.classList.add('dark'); else document.documentElement.classList.remove('dark');
                // Apply accent color CSS variable and persist theme/accent
                document.documentElement.style.setProperty('--theme-color', accentColor || THEMES[theme].bg);
                localStorage.setItem('fm_theme', theme);
                localStorage.setItem('fm_accent', accentColor);

                const cachedData = localStorage.getItem('fm_data');
                if(cachedData) setData(JSON.parse(cachedData));
                fetchData();
            }, [darkMode, theme, accentColor]);
            
            useEffect(() => { 
                setTimeout(() => lucide.createIcons(), 200); 
            }, [view, modal, data, rejectedItems, dialog, filterDays, theme, activeGraph, selectedFriend, isCalendarMode, calMonth, refreshing]);
            
            const fetchData = async (params = null) => {
                setLoading(true);
                try {
                    // Use explicit params if provided, otherwise fall back to lastFetchParams (if any)
                    const effectiveParams = params || lastFetchParams || {};
                    // Keep lastFetchParams in sync for refreshes
                    if (params) setLastFetchParams(params);

                    const q = new URLSearchParams({ action: 'getData', userId: currentUser.id, ...effectiveParams }).toString();
                    const res = await fetch(`${API_URL}?${q}`);
                    const json = await res.json();
                    if(json.success) {
                        const newData = { transactions: json.transactions, people: json.people };
                        setData(newData);
                        localStorage.setItem('fm_data', JSON.stringify(newData));
                        if(json.userProfile) setCurrentUser(json.userProfile);
                        const rejected = json.transactions.filter(t => t.userId === currentUser.id && t.status === 'Rejected');
                        if (rejected.length > 0) setRejectedItems(rejected);
                    } else {
                        console.warn('fetchData returned success=false', json);
                    }
                } catch(e) {
                    console.error('fetchData error', e);
                }
                setLoading(false);
            };

            // Periodic polling: refresh server data (people/transactions) every 30s while the page is visible
            useEffect(() => {
                let intervalId = null;
                const poll = async () => {
                    if (document.hidden) return;
                    try { await fetchData(lastFetchParams); } catch(e) { /* ignore */ }
                };
                // Kick off a poll shortly after mount
                const timeout = setTimeout(poll, 1500);
                intervalId = setInterval(poll, 30000);
                const onVis = () => { if (!document.hidden) poll(); };
                document.addEventListener('visibilitychange', onVis);
                return () => { clearTimeout(timeout); clearInterval(intervalId); document.removeEventListener('visibilitychange', onVis); };
            }, [lastFetchParams]);

            // Centralized mutation helper: supports skipFetch to avoid blocking re-fetch and UI flicker
            const mutate = async (body, { skipFetch = false } = {}) => {
                try {
                    const res = await fetch(API_URL, { method: 'POST', body: JSON.stringify(body) });
                    const json = await res.json();
                    if (!skipFetch) {
                        // Refresh latest data if caller wants canonical state
                        await fetchData(lastFetchParams);
                    }
                    return json;
                } catch (e) {
                    console.error('Mutation error', e);
                    throw e;
                }
            };

            // Optimistic mutate helper: apply optimistic UI immediately, then call server; rollback on error
            const optimisticMutate = async (body, applyOptimistic, rollback) => {
                try {
                    applyOptimistic();
                    const json = await mutate(body, { skipFetch: true });
                    if (json && json.success === false) {
                        rollback && rollback();
                        alert(json.error || 'Error');
                    }
                    return json;
                } catch (e) {
                    rollback && rollback();
                    alert('Error: ' + (e?.message || e));
                    throw e;
                }
            };
            
            const handleRefresh = () => {
                setRefreshing(true);
                setTimeout(() => window.location.reload(), 300);
            };
            
            const confirmAction = (title, msg, onConfirm, type='neutral') => setDialog({ isOpen: true, title, msg, onConfirm: () => { onConfirm(); setDialog({ isOpen: false }); }, onCancel: () => setDialog({ isOpen: false }), type });

            // Filter state & helpers
            const [lastFetchParams, setLastFetchParams] = useState(null);
            const applyFilters = (overrides = {}) => {
                // compute new filter values (allow overrides)
                const nextFilterDays = overrides.filterDays !== undefined ? overrides.filterDays : filterDays;
                const nextDateFrom = overrides.dateFrom !== undefined ? overrides.dateFrom : dateFrom;
                const nextDateTo = overrides.dateTo !== undefined ? overrides.dateTo : dateTo;
                const nextFilterType = overrides.filterType !== undefined ? overrides.filterType : filterType;
                const nextSearch = overrides.searchTerm !== undefined ? overrides.searchTerm : searchTerm;

                // Build params for backend
                const params = {};
                if (nextFilterDays === 'TODAY') {
                    const now = new Date(); now.setHours(0,0,0,0); const s = now.toISOString().split('T')[0]; params.dateFrom = s; params.dateTo = s;
                } else if (nextFilterDays === 'YESTERDAY') {
                    const now = new Date(); now.setHours(0,0,0,0); const y = new Date(now); y.setDate(y.getDate()-1); const s = y.toISOString().split('T')[0]; params.dateFrom = s; params.dateTo = s;
                } else if (nextFilterDays === '7' || nextFilterDays === '30') {
                    params.days = nextFilterDays;
                } else if (nextFilterDays === 'RANGE') {
                    if (nextDateFrom) params.dateFrom = nextDateFrom;
                    if (nextDateTo) params.dateTo = nextDateTo;
                } // ALL -> no date params

                if (nextFilterType && nextFilterType !== 'ALL') params.filterType = nextFilterType;
                if (nextSearch) params.search = nextSearch;

                // update local UI state and persist last params
                setFilterDays(nextFilterDays); setDateFrom(nextDateFrom); setDateTo(nextDateTo); setFilterType(nextFilterType); setSearchTerm(nextSearch);
                setLastFetchParams(params);
                // fetch with params (backend-aware)
                fetchData(params);
            };

            const clearFilters = () => {
                applyFilters({ filterDays: '7', filterType: 'ALL', dateFrom: null, dateTo: null, searchTerm: '' });
            };

            // FINANCIAL CORRECTNESS: Enhanced approval with state transition validation
            const handleApproval = (t, status) => {
                // Validate state transition
                if (!isValidTransition(t.status, status)) {
                    alert(`Invalid state transition: ${t.status} â†’ ${status}`);
                    return;
                }
                
                let title = 'Update Transaction?';
                if (status === 'Approved') title = 'Approve Transaction?';
                else if (status === 'Rejected') title = 'Reject Transaction?';
                else if (status === 'Marked as Paid') title = 'Mark as Paid?';
                else if (status === 'Confirmed') title = 'Confirm Transaction?';
                
                confirmAction(
                    title,
                    `This will update your financial records.`,
                    async () => {
                        const prevStatus = t.status;
                        await optimisticMutate({ action: 'handleApproval', transactionId: t.id, status: status, previousStatus: prevStatus },
                            () => {
                                // optimistic apply
                                setData(prev => ({ ...prev, transactions: prev.transactions.map(tr => tr.id === t.id ? { ...tr, status } : tr) }));
                            },
                            () => {
                                // rollback
                                setData(prev => ({ ...prev, transactions: prev.transactions.map(tr => tr.id === t.id ? { ...tr, status: prevStatus } : tr) }));
                            }
                        );
                    },
                    status === 'Rejected' ? 'danger' : 'neutral'
                );
            };
            
            // FINANCIAL CORRECTNESS: Enhanced payment confirmation flow
            const handlePaymentConfirmation = (t, status) => {
                if (t.status !== 'Marked as Paid' && status === 'Confirmed') {
                    alert('Transaction must be marked as paid before confirming receipt');
                    return;
                }
                
                if (!isValidTransition(t.status, status)) {
                    alert(`Invalid state transition: ${t.status} â†’ ${status}`);
                    return;
                }
                
                confirmAction(
                    status === 'Confirmed' ? 'Confirm Receipt?' : 'Mark as Not Received?',
                    `This will ${status === 'Confirmed' ? 'update balances' : 'return to approved state'}.`,
                    async () => {
                        const prevStatus = t.status;
                        // Use handleApproval backend action for all status updates
                        await optimisticMutate({ action: 'handleApproval', transactionId: t.id, status: status, previousStatus: prevStatus },
                            () => {
                                setData(prev => ({ ...prev, transactions: prev.transactions.map(tr => tr.id === t.id ? { ...tr, status } : tr) }));
                            },
                            () => {
                                setData(prev => ({ ...prev, transactions: prev.transactions.map(tr => tr.id === t.id ? { ...tr, status: prevStatus } : tr) }));
                            }
                        );
                    },
                    status === 'Not Received' ? 'danger' : 'neutral'
                );
            };
            
            // FINANCIAL CORRECTNESS: Enhanced friend removal with net balance check
            const removePerson = (p) => {
                // Calculate net balance for this person
                let net = 0;
                data.transactions.forEach(t => {
                    if (t.status === 'Rejected' || t.status === 'Deleted') return;
                    
                    const isMine = t.userId === currentUser.id;
                    if (!isMine && t.status === 'Pending') return;
                    
                    const amt = toCents(t.amount);
                    if (isMine && t.relatedPerson === p.id) {
                        if(t.type === 'lent') net += amt;
                        if(t.type === 'repayment_in') net -= amt;
                        if(t.type === 'borrowed') net -= amt;
                        if(t.type === 'repayment_out') net += amt;
                    }
                });
                
                if (Math.abs(net) > 0) {
                    alert(`Cannot remove friend with outstanding balance: ${formatMoney(fromCents(Math.abs(net)))}`);
                    return;
                }
                
                confirmAction('Remove Friend?', `Ensure balance is 0. This cannot be undone.`, async () => {
                    setLoading(true);
                    try {
                        const json = await mutate({ action: 'deletePerson', userId: currentUser.id, personId: p.id });
                        if(!json.success) alert(json.error || 'Error');
                    } catch(e) { alert("Error"); }
                    setLoading(false);
                }, 'danger');
            };
            
            const exportCSV = () => {
                const headers = ["Date", "Type", "Amount", "Category", "Description", "Friend", "Status", "State"];
                const rows = data.transactions.map(t => [t.date.split('T')[0], t.type, t.amount, t.category, `"${t.description}"`, t.relatedPerson || "-", t.status, t.state || '']);
                const csvContent = "data:text/csv;charset=utf-8," + headers.join(",") + "\n" + rows.map(e => e.join(",")).join("\n");
                const link = document.createElement("a");
                link.setAttribute("href", encodeURI(csvContent));
                link.setAttribute("download", "financemax_data.csv");
                document.body.appendChild(link);
                link.click();
            };
            
            // FIXED: RE-ENGINEERED FINANCIAL ENGINE WITH STRICT INVARIANTS
            const stats = useMemo(() => {
                let cashBal=0, onlineBal=0, asset=0, liability=0, income=0, expense=0;
                const graph = {}; 
                const catMap = {};
                
                data.transactions.forEach(t => {
                    // FINANCIAL RULE: Rejected/Deleted transactions are financially invisible
                    if (t.status === 'Rejected' || t.status === 'Deleted') return;
                    
                    const isMine = t.userId === currentUser.id;
                    
                    // FINANCIAL RULE: No balance mutation before Confirmed status
                    const canAffectBalances = canMutateBalances(t.status);
                    
                    const amt = toCents(t.amount);
                    const d = t.date.split('T')[0];
                    if(!graph[d]) graph[d] = {date:d, val:0};
                    
                    if (isMine) {
                        // FINANCIAL RULE: Only confirmed movements affect available balances
                        if (canAffectBalances) {
                            if (t.type === 'income') {
                                t.paymentMode === 'Cash' ? cashBal += amt : onlineBal += amt;
                                income += amt; 
                                graph[d].val += amt;
                            }
                            else if (t.type === 'expense') {
                                t.paymentMode === 'Cash' ? cashBal -= amt : onlineBal -= amt;
                                expense += amt; 
                                graph[d].val -= amt; 
                                const normalizedCategory = normalizeCategory(t.category);
                                catMap[normalizedCategory] = (catMap[normalizedCategory]||0)+amt;
                            }
                            else if (t.type === 'lent') {
                                t.paymentMode === 'Cash' ? cashBal -= amt : onlineBal -= amt;
                                asset += amt; 
                                graph[d].val -= amt;
                            }
                            else if (t.type === 'borrowed') {
                                t.paymentMode === 'Cash' ? cashBal += amt : onlineBal += amt;
                                liability += amt; 
                                graph[d].val += amt;
                            }
                            else if (t.type === 'repayment_in') {
                                t.paymentMode === 'Cash' ? cashBal += amt : onlineBal += amt;
                                asset -= amt; 
                                graph[d].val += amt;
                            }
                            else if (t.type === 'repayment_out') {
                                t.paymentMode === 'Cash' ? cashBal -= amt : onlineBal -= amt;
                                liability -= amt; 
                                graph[d].val -= amt;
                            }
                        }
                    } else {
                        // Synced transactions initiated by others
                        // FINANCIAL RULE: Only affect friend net if confirmed
                        if (canAffectBalances) {
                            if (t.type === 'lent') liability += amt;
                            else if (t.type === 'borrowed') asset += amt;
                            else if (t.type === 'repayment_in') liability -= amt;
                            else if (t.type === 'repayment_out') asset -= amt;
                        }
                    }
                });
                
                asset = Math.max(0, asset);
                liability = Math.max(0, liability);
                const pieData = Object.keys(catMap).map((k,i) => ({ name: k, value: fromCents(catMap[k]), color: COLORS[i % COLORS.length] }));
                const barData = [{ name: 'In', value: fromCents(income) }, { name: 'Out', value: fromCents(expense) }, { name: 'Lent', value: fromCents(asset) }, { name: 'Debt', value: fromCents(liability) }];
                
                let insight = "âœ… Financial health looks stable.";
                if(expense > income && income > 0) insight = "âš ï¸ Expenses exceed income.";
                if(liability > asset) insight = "ðŸ’¡ Tip: Debt > Assets.";
                
                // FIXED: Enhanced friend net calculation with proper direction
                const peopleStats = data.people.map(p => {
                    let net = 0;
                    data.transactions.forEach(t => {
                        // FINANCIAL RULE: Rejected/Deleted transactions don't affect net
                        if (t.status === 'Rejected' || t.status === 'Deleted') return;
                        
                        const isMine = t.userId === currentUser.id;
                        // FINANCIAL RULE: Pending sync transactions don't affect net
                        if (!isMine && t.status === 'Pending') return;
                        
                        const friendEmail = p.email ? p.email.toLowerCase() : "";
                        const creatorEmail = t.creatorEmail ? t.creatorEmail.toLowerCase() : "";
                        const amt = toCents(t.amount);
                        
                        if (isMine && t.relatedPerson === p.id) {
                            // FINANCIAL RULE: Only confirmed transactions affect net
                            if (canMutateBalances(t.status)) {
                                // I lent money to friend (they owe me) = POSITIVE
                                if(t.type === 'lent') net += amt;
                                // Friend repaid me (they gave back) = NEGATIVE
                                if(t.type === 'repayment_in') net -= amt;
                                // I borrowed from friend (I owe them) = NEGATIVE
                                if(t.type === 'borrowed') net -= amt;
                                // I repaid friend (I gave back) = POSITIVE
                                if(t.type === 'repayment_out') net += amt;
                            }
                        }
                        if (!isMine && creatorEmail === friendEmail) {
                            // FINANCIAL RULE: Only confirmed sync transactions affect net
                            if (canMutateBalances(t.status)) {
                                // Friend lent me money (they say I owe them) = NEGATIVE
                                if(t.type === 'lent') net -= amt;
                                // Friend says I borrowed from them (they owe me) = POSITIVE
                                if(t.type === 'borrowed') net += amt;
                                // Friend repaid me (they gave back) = POSITIVE
                                if(t.type === 'repayment_in') net += amt;
                                // Friend says I repaid them (I gave back) = NEGATIVE
                                if(t.type === 'repayment_out') net -= amt;
                            }
                        }
                    });
                    return { ...p, net: fromCents(net) };
                });
                
                return {
                    cashBal: fromCents(cashBal),
                    onlineBal: fromCents(onlineBal),
                    total: fromCents(cashBal+onlineBal),
                    rented: fromCents(asset),
                    taken: fromCents(liability),
                    insight,
                    pieData,
                    barData,
                    graphArea: Object.values(graph).sort((a,b)=>new Date(a.date)-new Date(b.date)).map(g=>({...g, val:fromCents(g.val)})),
                    peopleStats
                };
            }, [data.transactions, currentUser.id]);
            
            // FINANCIAL CORRECTNESS: Enhanced requests with multi-stage flow
            const requests = data.transactions.filter(t => {
                if (t.userId === currentUser.id) return false;
                // Show requests in different stages
                return t.status === 'Pending' || t.status === 'Approved' || t.status === 'Marked as Paid';
            });
            
            // TASK 1: Day-based Date Filter Logic (Before Aggregation)
            const filterTransactions = (list) => {
                const now = new Date(); now.setHours(0,0,0,0);
                return list.filter(t => {
                    // Exclude soft-deleted / rejected
                    if(t.status === 'Rejected' || t.status === 'Deleted') return false;

                    // Text search
                    const normalizedCategory = normalizeCategory(t.category);
                    const cat = (t.category || '').toString();
                    const desc = (t.description || '').toString();
                    const matchSearch = normalizedCategory.toLowerCase().includes(searchTerm.toLowerCase()) || 
                                       cat.toLowerCase().includes(searchTerm.toLowerCase()) || 
                                       desc.toLowerCase().includes(searchTerm.toLowerCase()) || 
                                       (t.amount !== undefined && t.amount !== null && t.amount.toString().includes(searchTerm));
                    if(!matchSearch) return false;

                    // Date normalization
                    const txDate = new Date(t.date); txDate.setHours(0,0,0,0);

                    // Calendar mode: exact date
                    if (isCalendarMode) {
                        if (txDate.toISOString().split('T')[0] !== selectedDate) return false;
                    } else {
                        // Date-range / preset filters
                        if (filterDays === 'ALL') {
                            // no date restriction
                        } else if (filterDays === 'TODAY') {
                            if (txDate.getTime() !== now.getTime()) return false;
                        } else if (filterDays === 'YESTERDAY') {
                            const yesterday = new Date(now); yesterday.setDate(yesterday.getDate() - 1);
                            if (txDate.getTime() !== yesterday.getTime()) return false;
                        } else if (filterDays === 'RANGE') {
                            // If both dates present, treat as inclusive range
                            if (dateFrom && dateTo) {
                                const from = new Date(dateFrom); from.setHours(0,0,0,0);
                                const to = new Date(dateTo); to.setHours(0,0,0,0);
                                if (txDate < from || txDate > to) return false;
                            } else if (dateFrom) {
                                const from = new Date(dateFrom); from.setHours(0,0,0,0);
                                if (txDate.getTime() !== from.getTime()) return false;
                            } // else no date constraints
                        } else {
                            // Numeric day presets and custom N (7, 30, CUSTOM)
                            let dLimit = 0;
                            if (filterDays === '7') dLimit = 7;
                            else if (filterDays === '30') dLimit = 30;
                            else if (filterDays === 'CUSTOM') {
                                const n = parseInt(customN);
                                dLimit = (isNaN(n) || n < 0) ? 0 : n;
                            }

                            if (dLimit > 0) {
                                const cutoff = new Date(now);
                                cutoff.setDate(cutoff.getDate() - dLimit);
                                if (txDate < cutoff) return false;
                            }
                        }
                    }

                    // Transaction type / flow filters
                    if (filterType && filterType !== 'ALL') {
                        const isMine = t.userId === currentUser.id;
                        let effectiveType = t.type;
                        if (!isMine) {
                            // Mirror types for synced transactions so semantics are consistent for the viewer
                            if (t.type === 'lent') effectiveType = 'borrowed';
                            else if (t.type === 'borrowed') effectiveType = 'lent';
                            else if (t.type === 'repayment_in') effectiveType = 'repayment_out';
                            else if (t.type === 'repayment_out') effectiveType = 'repayment_in';
                        }

                        const incomingTypes = ['income', 'borrowed', 'repayment_in'];
                        const outgoingTypes = ['expense', 'lent', 'repayment_out'];
                        const repaymentTypes = ['repayment_in', 'repayment_out'];

                        if (filterType === 'INCOMING' && !incomingTypes.includes(effectiveType)) return false;
                        if (filterType === 'OUTGOING' && !outgoingTypes.includes(effectiveType)) return false;
                        if (filterType === 'REPAYMENT' && !repaymentTypes.includes(effectiveType)) return false;
                    }

                    return true;
                });
            };
            
            const filteredHistory = filterTransactions(data.transactions);
            
            // TASK 2: Aggregating Summary Cards from Filtered Dataset
            const historySummary = useMemo(() => {
                let inc = 0, out = 0;
                filteredHistory.forEach(t => {
                    // FINANCIAL RULE: Only confirmed transactions affect summary
                    if (!canMutateBalances(t.status)) return;
                    
                    const isMine = t.userId === currentUser.id;
                    const amt = toCents(t.amount);
                    
                    if (isMine) {
                        if (['income', 'borrowed', 'repayment_in'].includes(t.type)) inc += amt;
                        else if (['expense', 'lent', 'repayment_out'].includes(t.type)) out += amt;
                    } else {
                        if (['borrowed', 'repayment_in'].includes(t.type)) inc += amt;
                        else if (['lent', 'repayment_out'].includes(t.type)) out += amt;
                    }
                });
                return { in: fromCents(inc), out: fromCents(out) };
            }, [filteredHistory, currentUser.id]);
            
            const calendarGrid = useMemo(() => {
                const firstDay = new Date(calYear, calMonth, 1).getDay();
                const daysInMonth = new Date(calYear, calMonth + 1, 0).getDate();
                const grid = [];
                for(let i=0; i<firstDay; i++) grid.push(null);
                for(let i=1; i<=daysInMonth; i++) {
                    const dateStr = new Date(calYear, calMonth, i).toISOString().split('T')[0];
                    const hasInc = data.transactions.some(t => t.date.startsWith(dateStr) && (t.type==='income'||t.type==='repayment_in'||t.type==='borrowed') && canMutateBalances(t.status));
                    const hasExp = data.transactions.some(t => t.date.startsWith(dateStr) && (t.type==='expense'||t.type==='lent'||t.type==='repayment_out') && canMutateBalances(t.status));
                    grid.push({ day: i, date: dateStr, hasInc, hasExp });
                }
                return grid;
            }, [calMonth, calYear, data.transactions]);
            
            const changeMonth = (dir) => { let m = calMonth + dir; let y = calYear; if(m > 11) { m=0; y++; } else if(m < 0) { m=11; y--; } setCalMonth(m); setCalYear(y); };
            
            // FIXED: Enhanced category intelligence for charts
            const enhancedPieData = useMemo(() => {
                const categoryGroups = {};
                
                // Group by main categories
                stats.pieData.forEach(item => {
                    const mainCategory = normalizeCategory(item.name);
                    categoryGroups[mainCategory] = (categoryGroups[mainCategory] || 0) + item.value;
                });
                
                // Sort by value (descending)
                const sortedGroups = Object.entries(categoryGroups)
                    .sort(([,a], [,b]) => b - a)
                    .map(([name, value], index) => ({ 
                        name, 
                        value,
                        color: COLORS[index % COLORS.length]
                    }));
                
                return sortedGroups;
            }, [stats.pieData]);
            
            // FIXED: Calendar View Rendering
            const renderCalendarView = () => {
                return (
                    <div className="space-y-4">
                        <div className="flex justify-between items-center px-4">
                            <button onClick={() => changeMonth(-1)} className="p-2 rounded-full bg-slate-100 dark:bg-slate-800">
                                <i data-lucide="chevron-left" className="w-5 h-5"></i>
                            </button>
                            <h3 className="font-bold dark:text-white">
                                {new Date(calYear, calMonth).toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}
                            </h3>
                            <button onClick={() => changeMonth(1)} className="p-2 rounded-full bg-slate-100 dark:bg-slate-800">
                                <i data-lucide="chevron-right" className="w-5 h-5"></i>
                            </button>
                        </div>
                        <div className="grid grid-cols-7 gap-1 px-4">
                            {['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map(day => (
                                <div key={day} className="text-center text-xs font-bold text-slate-400 py-2">{day}</div>
                            ))}
                            {calendarGrid.map((day, idx) => (
                                <div key={idx} className={`min-h-12 p-1 ${!day ? 'invisible' : ''}`}>
                                    {day && (
                                        <button
                                            onClick={() => {
                                                setSelectedDate(day.date);
                                                setIsCalendarMode(false);
                                            }}
                                            className={`w-full h-full rounded-lg flex flex-col items-center justify-center text-sm font-bold transition-all
                                                ${selectedDate === day.date ? 'bg-indigo-500 text-white' : 
                                                  'bg-white dark:bg-slate-800 hover:bg-slate-100 dark:hover:bg-slate-700'}`}
                                        >
                                            <span>{day.day}</span>
                                            <div className="flex gap-1 mt-1">
                                                {day.hasInc && <div className="w-1.5 h-1.5 rounded-full bg-emerald-500"></div>}
                                                {day.hasExp && <div className="w-1.5 h-1.5 rounded-full bg-red-500"></div>}
                                            </div>
                                        </button>
                                    )}
                                </div>
                            ))}
                        </div>
                    </div>
                );
            };
            
            return (
                <div className="h-full w-full flex flex-col bg-slate-50 dark:bg-slate-950">
                    <header className="px-6 py-4 bg-white dark:bg-slate-900 border-b border-slate-200 dark:border-slate-800 flex justify-between items-center z-20">
                        <div className="flex items-center gap-3"><Avatar imageId={currentUser.imageId} name={currentUser.name} theme={theme} /><div><h1 className="font-bold dark:text-white leading-tight">Hi, {currentUser.name.split(' ')[0]}</h1></div></div>
                        <div className="flex gap-2">
                            <button onClick={handleRefresh} className={`icon-btn flex items-center justify-center ${refreshing ? 'animate-spin-once' : ''}`} style={{color: THEMES[theme].bg, transition: 'all 0.3s'}}><i data-lucide="refresh-cw" className="w-5 h-5"></i></button>
                            <button onClick={()=>setDarkMode(!darkMode)} className="icon-btn"><i data-lucide={darkMode?"sun":"moon"} className="w-5 h-5"></i></button>
                            <button onClick={onLogout} className="icon-btn text-red-500 bg-red-50 dark:bg-red-900/20"><i data-lucide="log-out" className="w-5 h-5"></i></button>
                        </div>
                    </header>
                    <div className="flex-1 overflow-y-auto p-4 pb-24 space-y-6">
                       
                        {view === 'home' && (
                            <div className="space-y-6 animate-fade">
                                <div className="glass p-6 rounded-[2rem] text-white shadow-xl shadow-indigo-500/30" style={{background: `linear-gradient(135deg, ${THEMES[theme].bg} 0%, #1e1b4b 100%)`}}>
                                    <p className="text-white/70 text-xs font-bold uppercase tracking-wider mb-1">Total Actual Balance</p>
                                    <h2 className="text-4xl font-bold">{formatMoney(stats.total)}</h2>
                                    <div className="mt-6 flex gap-3">
                                        <div className="bg-white/10 px-4 py-2 rounded-xl border border-white/10 backdrop-blur-md flex-1"><p className="text-[10px] text-white/70 font-bold uppercase">Online</p><p className="font-bold text-lg">{formatMoney(stats.onlineBal)}</p></div>
                                        <div className="bg-white/10 px-4 py-2 rounded-xl border border-white/10 backdrop-blur-md flex-1"><p className="text-[10px] text-white/70 font-bold uppercase">Cash</p><p className="font-bold text-lg">{formatMoney(stats.cashBal)}</p></div>
                                    </div>
                                </div>
                                <div className="p-3 bg-blue-50 dark:bg-blue-900/20 text-blue-600 dark:text-blue-300 text-xs font-bold rounded-xl flex items-center gap-3 border border-blue-100 dark:border-blue-900/50"><i data-lucide="sparkles" className="w-5 h-5 shrink-0"></i>{stats.insight}</div>
                                {parseInt(budget) > 0 && (<div className="bg-white dark:bg-slate-900 p-4 rounded-[1.5rem] shadow-sm border border-slate-200 dark:border-slate-800"><div className="flex justify-between text-xs font-bold mb-2"><span className="text-slate-500">Monthly Budget</span><span>{formatMoney(stats.pieData.reduce((a,b)=>a+b.value,0))} / {formatMoney(budget)}</span></div><div className="h-3 bg-slate-100 dark:bg-slate-800 rounded-full overflow-hidden"><div className={`h-full rounded-full transition-all duration-500 ${THEMES[theme].class}`} style={{width: `${Math.min(100, (stats.pieData.reduce((a,b)=>a+b.value,0)/parseInt(budget))*100)}%`}}></div></div></div>)}
                                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                                    <div className="bg-white dark:bg-slate-900 p-5 rounded-[1.5rem] shadow-sm"><p className="text-[10px] font-bold text-slate-400 uppercase mb-1">Assets (Rented)</p><p className="text-xl font-bold" style={{color: accentColor}}>{formatMoney(stats.rented)}</p></div>
                                    <div className="bg-white dark:bg-slate-900 p-5 rounded-[1.5rem] shadow-sm"><p className="text-[10px] font-bold text-slate-400 uppercase mb-1">Liabilities (Taken)</p><p className="text-xl font-bold" style={{color: accentColor}}>{formatMoney(stats.taken)}</p></div>
                                </div>
                                <div className="flex justify-center bg-slate-100 dark:bg-slate-800 p-1 rounded-xl">{['trend', 'bar', 'pie'].map(g => (<button key={g} onClick={()=>setActiveGraph(g)} className={`flex-1 py-2 text-xs font-bold rounded-lg capitalize transition-all ${activeGraph===g ? 'bg-white dark:bg-slate-700 shadow text-slate-900 dark:text-white' : 'text-slate-400'}`}>{g === 'trend' ? 'Cash Flow' : g === 'bar' ? 'Analysis' : 'Category'}</button>))}</div>
                                <div className="h-64 bg-white dark:bg-slate-900 rounded-[2rem] p-4 shadow-sm border border-slate-200 dark:border-slate-800">
                                    <ResponsiveContainer width="100%" height="100%">
                                        {activeGraph === 'trend' ? (
                                            <AreaChart data={stats.graphArea}>
                                                <defs><linearGradient id="c" x1="0" y1="0" x2="0" y2="1"><stop offset="5%" stopColor={THEMES[theme].bg} stopOpacity={0.3}/><stop offset="95%" stopColor={THEMES[theme].bg} stopOpacity={0}/></linearGradient></defs>
                                                <Tooltip contentStyle={{backgroundColor:'#0f172a', border:'none', borderRadius:'12px', color:'#fff'}} formatter={(value) => formatMoney(value)} />
                                                <Area type="monotone" dataKey="val" stroke={THEMES[theme].bg} fill="url(#c)" strokeWidth={3} />
                                            </AreaChart>
                                        ) : activeGraph === 'bar' ? (
                                            <BarChart data={stats.barData}>
                                                <XAxis dataKey="name" tick={{fontSize: 10}} stroke="#94a3b8" />
                                                <Tooltip contentStyle={{backgroundColor:'#0f172a', border:'none', borderRadius:'12px', color:'#fff'}} formatter={(value) => formatMoney(value)} cursor={{fill: 'transparent'}} />
                                                <Bar dataKey="value" fill={THEMES[theme].bg} radius={[4, 4, 0, 0]} />
                                            </BarChart>
                                        ) : (
                                            <PieChart>
                                                <Pie data={enhancedPieData} innerRadius={60} outerRadius={80} paddingAngle={5} dataKey="value" nameKey="name">
                                                    {enhancedPieData.map((entry, index) => (<Cell key={`cell-${index}`} fill={entry.color} />))}
                                                </Pie>
                                                <Tooltip contentStyle={{backgroundColor:'#0f172a', border:'none', borderRadius:'12px', color:'#fff'}} formatter={(value) => formatMoney(value)} />
                                                <Legend />
                                            </PieChart>
                                        )}
                                    </ResponsiveContainer>
                                </div>
                            </div>
                        )}
                        
                        {/* FINANCIAL CORRECTNESS: Enhanced Requests Tab with Multi-Stage Flow */}
                        {view === 'requests' && (
                            <div className="space-y-4 animate-fade">
                                <h2 className="text-xl font-bold dark:text-white px-2">Transaction Requests</h2>
                                {requests.length === 0 && <p className="text-center text-slate-400 mt-10">No pending requests.</p>}
                                {requests.map(t => {
                                    let type = t.type;
                                    if(type === 'lent') type = 'borrowed'; 
                                    else if(type === 'borrowed') type = 'lent';
                                    else if(type === 'repayment_in') type = 'repayment_out'; 
                                    else if(type === 'repayment_out') type = 'repayment_in';
                                    
                                    const isPending = t.status === 'Pending';
                                    const isApproved = t.status === 'Approved';
                                    const isMarkedPaid = t.status === 'Marked as Paid';
                                    
                                    return (
                                        <div key={t.id} className="p-4 bg-white dark:bg-slate-900 rounded-2xl border border-indigo-200 dark:border-indigo-900 shadow-sm">
                                            <div className="flex justify-between items-start mb-4">
                                                <div>
                                                    <p className="text-xs font-bold text-indigo-500 uppercase tracking-wider mb-1">{t.creatorEmail}</p>
                                                    <p className="font-bold dark:text-white text-lg">{t.category}</p>
                                                    <p className="text-slate-400 text-sm">{t.description}</p>
                                                    <div className="mt-2">
                                                        <TransactionStateBadge status={t.status} theme={theme} />
                                                    </div>
                                                </div>
                                                <div className="text-right">
                                                    <span className="font-bold text-xl block dark:text-white">{formatMoney(t.amount)}</span>
                                                    <span className={`text-[10px] font-bold uppercase px-2 py-1 rounded ${type==='borrowed'?'bg-amber-100 text-amber-600':'bg-blue-100 text-blue-600'}`}>
                                                        {type === 'borrowed' ? 'You Owe' : 'They Owe'}
                                                    </span>
                                                </div>
                                            </div>
                                            
                                            {/* Multi-stage action buttons */}
                                            <div className="flex flex-col sm:flex-row gap-3">
                                                {isPending && (
                                                    <>
                                                        <button onClick={()=>handleApproval(t, 'Rejected')} className="flex-1 py-3 rounded-xl bg-red-50 text-red-600 font-bold border border-red-100 hover:bg-red-100 dark:bg-red-900/20 dark:border-red-900/50">
                                                            Reject
                                                        </button>
                                                        <button onClick={()=>handleApproval(t, 'Approved')} className="flex-1 py-3 rounded-xl bg-emerald-50 text-emerald-600 font-bold border border-emerald-100 hover:bg-emerald-100 dark:bg-emerald-900/20 dark:border-emerald-900/50">
                                                            Approve
                                                        </button>
                                                    </>
                                                )}
                                                
                                                {isApproved && (
                                                    <>
                                                        <button onClick={()=>handleApproval(t, 'Marked as Paid')} className="flex-1 py-3 rounded-xl bg-blue-50 text-blue-600 font-bold border border-blue-100 hover:bg-blue-100 dark:bg-blue-900/20 dark:border-blue-900/50">
                                                            Mark as Paid
                                                        </button>
                                                        <button onClick={()=>window.open(`upi://pay?pa=${t.upiId || 'example@upi'}&pn=${t.creatorEmail}&am=${t.amount}&cu=INR`, '_blank')} className="flex-1 py-3 rounded-xl bg-indigo-50 text-indigo-600 font-bold border border-indigo-100 hover:bg-indigo-100 dark:bg-indigo-900/20 dark:border-indigo-900/50">
                                                            Pay Now (UPI)
                                                        </button>
                                                    </>
                                                )}
                                                
                                                {isMarkedPaid && (
                                                    <>
                                                        <button onClick={()=>handlePaymentConfirmation(t, 'Not Received')} className="flex-1 py-3 rounded-xl bg-amber-50 text-amber-600 font-bold border border-amber-100 hover:bg-amber-100 dark:bg-amber-900/20 dark:border-amber-900/50">
                                                            Not Received
                                                        </button>
                                                        <button onClick={()=>handlePaymentConfirmation(t, 'Confirmed')} className="flex-1 py-3 rounded-xl bg-emerald-50 text-emerald-600 font-bold border border-emerald-100 hover:bg-emerald-100 dark:bg-emerald-900/20 dark:border-emerald-900/50">
                                                            Confirm Receipt
                                                        </button>
                                                    </>
                                                )}
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        )}
                        
                        {(view === 'history' || (view === 'people' && selectedFriend)) && (
                            <div className="space-y-4 animate-fade">
                                <div className="flex justify-between items-center px-2">
                                    <h2 className="text-xl font-bold dark:text-white">{selectedFriend ? `History w/ ${selectedFriend.name}` : isCalendarMode ? 'Calendar View' : 'Transactions'}</h2>
                                    {!selectedFriend && <button onClick={()=>setIsCalendarMode(!isCalendarMode)} className={`p-2 rounded-full ${isCalendarMode ? THEMES[theme].class + ' text-white' : 'bg-slate-200 dark:bg-slate-800 text-slate-500'}`}><i data-lucide={isCalendarMode?"list":"calendar"} className="w-5 h-5"></i></button>}
                                </div>
                               
                                {/* Calendar View */}
                                {isCalendarMode && renderCalendarView()}
                               
                                {/* Regular History View */}
                                {!isCalendarMode && (
                                    <>
                                        {/* TASK 1: History Section Date Filters */}
                                        {!selectedFriend && (
                                            <div className="px-2 space-y-3">
                                                <div className="scroll-x flex gap-2 pb-1">
                                                    {[
                                                        { id: 'TODAY', label: 'Today' },
                                                        { id: 'YESTERDAY', label: 'Yesterday' },
                                                        { id: '7', label: 'Last 7 Days' },
                                                        { id: '30', label: 'Last 30 Days' },
                                                        { id: 'RANGE', label: 'Range' },
                                                        { id: 'ALL', label: 'All Time' }
                                                    ].map(f => (
                                                        <button key={f.id} onClick={()=>{
                                                            setFilterDays(f.id);
                                                            const now = new Date(); now.setHours(0,0,0,0);
                                                            if(f.id === 'TODAY') { const s = now.toISOString().split('T')[0]; setDateFrom(s); setDateTo(s); }
                                                            else if(f.id === 'YESTERDAY') { const y = new Date(now); y.setDate(y.getDate()-1); const s = y.toISOString().split('T')[0]; setDateFrom(s); setDateTo(s); }
                                                            else if(f.id === 'RANGE') { const s = now.toISOString().split('T')[0]; setDateFrom(s); setDateTo(s); }
                                                            else { setDateFrom(null); setDateTo(null); }
                                                        }} className={`px-4 py-2 rounded-full text-[10px] font-bold uppercase tracking-tight transition-all ${filterDays===f.id ? THEMES[theme].class + ' text-white shadow-md' : 'bg-white dark:bg-slate-900 text-slate-500 border border-slate-200 dark:border-slate-800'}`}>{f.label}</button>
                                                    ))}
                                                </div>
                                                {filterDays === 'RANGE' && (
                                                    <div className="flex items-center gap-2 animate-fade">
                                                        <span className="text-xs font-bold text-slate-400 uppercase">From</span>
                                                        <input type="date" className="p-2 rounded-lg bg-white dark:bg-slate-900 border border-slate-200 dark:border-slate-800 text-sm outline-none" value={dateFrom || ''} onChange={e=>setDateFrom(e.target.value)} />
                                                        <span className="text-xs font-bold text-slate-400 uppercase">To</span>
                                                        <input type="date" className="p-2 rounded-lg bg-white dark:bg-slate-900 border border-slate-200 dark:border-slate-800 text-sm outline-none" value={dateTo || ''} onChange={e=>setDateTo(e.target.value)} />
                                                        <button onClick={()=>{ setFilterDays('RANGE'); }} className="py-1 px-2 rounded-md text-xs bg-slate-100 dark:bg-slate-800">Apply</button>
                                                    </div>
                                                )}

                                                {/* Transaction Type Filters: ALL / INCOMING / OUTGOING / REPAYMENT */}
                                                <div className="flex items-center gap-2 mt-3">
                                                    <span className="text-xs font-bold text-slate-400 uppercase">Type</span>
                                                    {[
                                                        { id: 'ALL', label: 'All' },
                                                        { id: 'INCOMING', label: 'Incoming' },
                                                        { id: 'OUTGOING', label: 'Outgoing' },
                                                        { id: 'REPAYMENT', label: 'Repayment' }
                                                    ].map(ft => (
                                                        <button key={ft.id} onClick={() => setFilterType(ft.id)} className={`px-3 py-2 rounded-full text-[10px] font-bold uppercase tracking-tight transition-all ${filterType===ft.id ? THEMES[theme].class + ' text-white shadow-md' : 'bg-white dark:bg-slate-900 text-slate-500 border border-slate-200 dark:border-slate-800'}`}>
                                                            {ft.label}
                                                        </button>
                                                    ))}
                                                </div>
                                            </div>
                                        )}
                                        {/* TASK 2: History Summary Cards */}
                                        <div className="grid grid-cols-2 gap-3 px-2">
                                            <div className="bg-white dark:bg-slate-900 p-4 rounded-2xl border border-slate-100 dark:border-slate-800 shadow-sm">
                                                <div className="flex items-center gap-2 mb-1">
                                                    <div className="w-2 h-2 rounded-full bg-emerald-500"></div>
                                                    <p className="text-[10px] font-bold text-slate-400 uppercase mb-1">Incoming</p>
                                                </div>
                                                <p className="text-lg font-bold text-emerald-600">{formatMoney(historySummary.in)}</p>
                                            </div>
                                            <div className="bg-white dark:bg-slate-900 p-4 rounded-2xl border border-slate-100 dark:border-slate-800 shadow-sm">
                                                <div className="flex items-center gap-2 mb-1">
                                                    <div className="w-2 h-2 rounded-full bg-red-500"></div>
                                                    <p className="text-[10px] font-bold text-slate-400 uppercase mb-1">Outgoing</p>
                                                </div>
                                                <p className="text-lg font-bold text-red-600">{formatMoney(historySummary.out)}</p>
                                            </div>
                                        </div>
                                        <div className="px-4 mb-2"><div className="flex items-center bg-white dark:bg-slate-900 rounded-xl px-3 py-3 border border-slate-200 dark:border-slate-800"><i data-lucide="search" className="w-4 h-4 text-slate-400 mr-2"></i><input className="bg-transparent outline-none w-full text-sm dark:text-white" placeholder="Search..." value={searchTerm} onChange={e => setSearchTerm(e.target.value)} /></div></div>
                                       
                                        {filteredHistory.length === 0 && <p className="text-center text-slate-400 mt-10">No transactions found.</p>}
                                       
                                        {filteredHistory.map(t => {
                                            const isMine = t.userId === currentUser.id;
                                            let effectiveType = t.type; 
                                            let displayType = t.type;
                                            const whoPaidText = isMine ? "Paid by You" : `Paid by ${t.creatorEmail?.split('@')[0] || 'Unknown'}`;
                                            const normalizedCategory = normalizeCategory(t.category);
                                            
                                            if(selectedFriend) {
                                                const friendEmail = selectedFriend.email ? selectedFriend.email.toLowerCase() : "";
                                                const creatorEmail = t.creatorEmail ? t.creatorEmail.toLowerCase() : "";
                                                const isRelated = (isMine && t.relatedPerson === selectedFriend.id) || (!isMine && creatorEmail === friendEmail);
                                                if(!isRelated) return null;
                                            }
                                            
                                            if(!isMine) { 
                                                if (t.type === 'lent') effectiveType = 'borrowed'; 
                                                else if (t.type === 'borrowed') effectiveType = 'lent'; 
                                                else if (t.type === 'repayment_in') effectiveType = 'repayment_out'; 
                                                else if (t.type === 'repayment_out') effectiveType = 'repayment_in'; 
                                                displayType = effectiveType; 
                                            }
                                            
                                            return (
                                                <div key={t.id} onClick={() => isMine ? (setEditItem(t), setModal('add')) : alert("Synced Transaction. Cannot edit.")} className={`flex justify-between items-center p-4 bg-white dark:bg-slate-900 rounded-2xl border ${!isMine ? 'border-dashed border-indigo-300 dark:border-indigo-800' : 'border-slate-200 dark:border-slate-800'} shadow-sm cursor-pointer hover:bg-slate-50 dark:hover:bg-slate-800 transition`}>
                                                    <div className="flex gap-4 items-center">
                                                        <div className={`w-12 h-12 rounded-2xl flex items-center justify-center text-xl shrink-0 ${displayType.includes('income')?'bg-emerald-50 text-emerald-600 dark:bg-emerald-900/20':displayType.includes('expense')?'bg-red-50 text-red-600 dark:bg-red-900/20':'bg-blue-50 text-blue-600 dark:bg-blue-900/20'}`}>
                                                            <i data-lucide={displayType==='income'?'arrow-down':displayType==='expense'?'arrow-up':'refresh-cw'} className="w-5 h-5"></i>
                                                        </div>
                                                        <div className="min-w-0">
                                                            <p className="text-[10px] font-bold text-slate-400 uppercase tracking-wide">{whoPaidText}</p>
                                                            <div className="flex items-center gap-2">
                                                                <TransactionStateBadge status={t.status} theme={theme} iconOnly={true} small={true} />
                                                                <p className="font-bold text-sm dark:text-white truncate">
                                                                    {t.category} 
                                                                    {normalizedCategory !== t.category && <span className="text-[10px] text-slate-500 ml-1">({normalizedCategory})</span>}
                                                                    {!isMine && <span className="text-[10px] text-indigo-500 bg-indigo-50 px-1 rounded ml-1">SYNC</span>}
                                                                </p>
                                                            </div>
                                                            <div className="flex items-center gap-1">
                                                                <p className="text-xs text-slate-500 font-medium">{t.date.split('T')[0]} â€¢ {t.paymentMode}</p>
                                                                {t.imageId && <i data-lucide="paperclip" className="w-3 h-3 text-indigo-500"></i>}
                                                            </div>
                                                        </div>
                                                    </div>
                                                    <div className="text-right shrink-0">
                                                        <span className="font-bold block dark:text-white text-lg">{formatMoney(t.amount)}</span>
                                                        <span className="text-[10px] font-bold uppercase text-slate-400">
                                                            {displayType==='income'?'In':displayType==='expense'?'Out':displayType==='borrowed'?'Debt':'Lent'}
                                                        </span>
                                                    </div>
                                                </div>
                                            );
                                        })}
                                    </>
                                )}
                            </div>
                        )}
                        
                        {view === 'people' && !selectedFriend && (
                            <div className="space-y-4 animate-fade">
                                <div className="px-4 mb-2"><div className="flex items-center bg-white dark:bg-slate-900 rounded-xl px-3 py-3 border border-slate-200 dark:border-slate-800"><i data-lucide="search" className="w-4 h-4 text-slate-400 mr-2"></i><input className="bg-transparent outline-none w-full text-sm dark:text-white" placeholder="Search friends..." value={searchTerm} onChange={e => setSearchTerm(e.target.value)} /></div></div>
                                <div className="flex justify-between items-center px-2"><h2 className="text-xl font-bold dark:text-white">Friends</h2><button onClick={()=>{setEditItem(null); setModal('person');}} className={`text-white px-3 py-2 rounded-md text-xs font-bold shadow-lg ${THEMES[theme].class}`}>+ Add Friend</button></div>
                                {stats.peopleStats.filter(p=>p.name.toLowerCase().includes(searchTerm.toLowerCase())).map(p => {
                                    // FIXED: Correct display logic for friend balances
                                    const displayText = p.net > 0 
                                        ? `You will get ${formatMoney(p.net)}` 
                                        : p.net < 0 
                                            ? `You need to pay ${formatMoney(Math.abs(p.net))}`
                                            : 'Settled';
                                    
                                    const displayColor = p.net > 0 
                                        ? 'text-emerald-500' 
                                        : p.net < 0 
                                            ? 'text-red-500' 
                                            : 'text-slate-400';
                                    
                                    return (
                                        <div key={p.id} onClick={()=>setSelectedFriend(p)} className="flex items-center justify-between p-3 sm:p-4 bg-white dark:bg-slate-900 rounded-2xl border border-slate-200 dark:border-slate-800 shadow-sm cursor-pointer hover:bg-slate-50 dark:hover:bg-slate-800">
                                            <div className="flex items-center gap-3">
                                                <Avatar imageId={p.imageId} name={p.name} theme={theme} />
                                                <div>
                                                    <div className="flex items-center gap-2">
                                                        <p className="font-bold dark:text-white">{p.name}</p>
                                                        {p.email && <span className="text-[10px] bg-indigo-100 text-indigo-600 px-1 rounded font-bold">LINKED</span>}
                                                        {!p.email && <span className="text-[10px] bg-amber-100 text-amber-700 px-1 rounded font-bold">MANUAL</span>}
                                                    </div>
                                                    <p className={`text-xs font-bold ${displayColor}`}>
                                                        {displayText}
                                                    </p>
                                                </div>
                                            </div>
                                            <button onClick={(e)=>{e.stopPropagation(); removePerson(p);}} className="p-2 text-slate-400 hover:text-red-500 hover:bg-red-50 dark:hover:bg-red-900/20 rounded-full transition"><i data-lucide="trash-2" className="w-4 h-4"></i></button>
                                        </div>
                                    );
                                })}
                            </div>
                        )}
                        
                        {view === 'profile' && (
                            <div className="space-y-6 animate-fade">
                                <ProfileView user={currentUser} onUpdate={u => setCurrentUser(u)} theme={theme} setTheme={setTheme} setAccentColor={setAccentColor} mutate={mutate} />
                                <div className="px-4"><p className="text-xs font-bold text-slate-400 uppercase mb-3">Settings</p>
                                    <div className="bg-white dark:bg-slate-900 rounded-[1.5rem] p-4 space-y-4">
                                        <div className="flex justify-between items-center"><span className="text-sm font-bold dark:text-white">Monthly Budget</span><input type="number" className="w-24 text-right bg-slate-100 dark:bg-slate-800 rounded-lg px-2 py-1 text-sm outline-none" placeholder="0" value={budget} onChange={e=>{setBudget(e.target.value); localStorage.setItem('fm_budget', e.target.value);}} /></div>
                                        <div className="flex justify-between items-center theme-row"><span className="text-sm font-bold dark:text-white">Theme</span>
                                            <div className="flex gap-2 items-center min-w-0">
                                                <div className="theme-swatches flex-1 flex flex-wrap gap-2 min-w-0">
                                                    {Object.keys(THEMES).map(c => (
                                                        <button key={c} onClick={()=>{setTheme(c); localStorage.setItem('fm_theme', c); setAccentColor(THEMES[c].bg);}} className={`swatch w-6 h-6 rounded-full cursor-pointer border-2 ${theme===c?'border-slate-900 dark:border-white':'border-transparent'}`} style={{backgroundColor:THEMES[c].bg}} aria-label={`Theme ${c}`} title={c}></button>
                                                    ))}
                                                </div>
                                                <input type="color" value={accentColor} onChange={e=>{setAccentColor(e.target.value); localStorage.setItem('fm_accent', e.target.value);}} className="ml-2 w-8 h-8 p-0 border-0" />
                                            </div>
                                        </div>
                                        <button onClick={exportCSV} className="w-full py-3 bg-slate-100 dark:bg-slate-800 text-slate-600 dark:text-slate-300 font-bold rounded-xl text-sm flex justify-center gap-2"><i data-lucide="download" className="w-4 h-4"></i> Export Data (CSV)</button>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                    <button onClick={()=>{setEditItem(null); setModal('add');}} className={`absolute bottom-16 sm:bottom-24 right-4 sm:right-6 w-12 sm:w-16 h-12 sm:h-16 text-white rounded-full shadow-xl flex items-center justify-center z-30 transition-transform active:scale-90 ${THEMES[theme].class}`}><i data-lucide="plus" className="w-6 sm:w-8 h-6 sm:h-8"></i></button>
                    <div className="absolute bottom-0 w-full bg-white dark:bg-slate-900 border-t border-slate-200 dark:border-slate-800 px-4 py-3 sm:px-6 flex justify-between items-center z-40 pb-safe">
                        {['home','history','people','requests','profile'].map(v => (
                            <button key={v} onClick={()=>{setView(v); setSelectedFriend(null); setIsCalendarMode(false);}} className={`flex flex-col items-center gap-1 transition-all ${view===v?THEMES[theme].text + ' scale-110':'text-slate-400 dark:text-slate-600'}`}>
                                <div className="relative"><i data-lucide={v==='home'?'home':v==='history'?'list':v==='people'?'users':v==='requests'?'bell':'user'} className={`w-6 h-6 ${view===v && 'fill-current opacity-20'}`}></i>{v==='requests' && requests.length > 0 && <span className="absolute -top-1 -right-1 w-3 h-3 bg-red-500 rounded-full border-2 border-white dark:border-slate-900"></span>}</div>
                            </button>
                        ))}
                    </div>
                    {selectedFriend && (
                        <div className="absolute top-0 left-0 w-full h-20 bg-white dark:bg-slate-900 flex items-center px-4 z-50 border-b border-slate-200 dark:border-slate-800 animate-fade">
                            <button onClick={()=>setSelectedFriend(null)} className="p-2 -ml-2 text-slate-500"><i data-lucide="arrow-left" className="w-6 h-6"></i></button>
                            <div className="ml-3 flex items-center gap-3">
                                <Avatar imageId={selectedFriend.imageId} name={selectedFriend.name} theme={theme} />
                                <div>
                                    <h2 className="font-bold text-lg dark:text-white">{selectedFriend.name}</h2>
                                    <p className={`text-xs font-bold ${selectedFriend.net > 0 ? 'text-emerald-500' : selectedFriend.net < 0 ? 'text-red-500' : 'text-slate-400'}`}>
                                        {selectedFriend.net > 0 
                                            ? `Owes you ${formatMoney(selectedFriend.net)}` 
                                            : selectedFriend.net < 0 
                                                ? `You owe ${formatMoney(Math.abs(selectedFriend.net))}` 
                                                : 'Settled'}
                                    </p>
                                </div>
                            </div>
                        </div>
                    )}
                    <ConfirmDialog isOpen={dialog.isOpen} title={dialog.title} msg={dialog.msg} onConfirm={dialog.onConfirm} onCancel={dialog.onCancel} type={dialog.type} theme={theme} single={dialog.single} confirmLabel={dialog.confirmLabel} />
                   
                    {rejectedItems.length > 0 && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center bg-slate-900/60 backdrop-blur-sm p-4 animate-fade">
                            <div className="bg-white dark:bg-slate-900 w-full max-w-sm rounded-[2rem] p-6 shadow-2xl animate-up relative text-center">
                                <button onClick={()=>setRejectedItems(prev=>prev.slice(1))} className="absolute top-4 right-4 text-slate-400 hover:text-slate-600"><i data-lucide="x" className="w-5 h-5"></i></button>
                                <div className="w-16 h-16 bg-red-100 text-red-500 rounded-full flex items-center justify-center mx-auto mb-4"><i data-lucide="alert-circle" className="w-8 h-8"></i></div>
                                <h3 className="font-bold text-xl dark:text-white mb-2">Request Rejected</h3>
                                <p className="text-slate-500 text-sm mb-6">Your transaction "{rejectedItems[0].description}" of {formatMoney(rejectedItems[0].amount)} was rejected.</p>
                                <div className="flex gap-3">
                                    <button onClick={()=>{confirmAction('Delete Record?', 'This will permanently delete this rejected request.', ()=>{ mutate({ action:'delete', id:rejectedItems[0].id, userId:currentUser.id }).then(json => { if(!json || json.success === false) alert(json?.error || 'Error'); setRejectedItems(prev => prev.slice(1)); }); }, 'danger');}} className="flex-1 py-3 rounded-xl bg-red-50 text-red-600 font-bold">Delete</button>
                                    <button onClick={async ()=>{ const { id, status, ...retryData } = rejectedItems[0]; if(retryData.date) retryData.date = retryData.date.split('T')[0]; try { setLoading(true); const json = await mutate({ action:'delete', id:rejectedItems[0].id, userId:currentUser.id }); if(json && json.success) { setEditItem(retryData); setModal('add'); setRejectedItems(prev => prev.slice(1)); } else { alert(json?.error || 'Error'); } } catch (e) { alert('Error'); } finally { setLoading(false); } }} className={`flex-1 py-3 rounded-xl text-white font-bold shadow-lg ${THEMES[theme].class}`}>Retry</button>
                                </div>
                            </div>
                        </div>
                    )}
                   
                    {modal === 'add' && <TransactionModal user={currentUser} people={data.people} editItem={editItem} onClose={()=>{setModal(null); fetchData(lastFetchParams);}} theme={theme} mutate={mutate} setData={setData} data={data} fetchData={fetchData} lastFetchParams={lastFetchParams} setDialog={setDialog} /> }
                    {modal === 'person' && <PersonModal user={currentUser} onClose={()=>{setModal(null); fetchData(lastFetchParams);}} theme={theme} mutate={mutate} /> }
                </div>
            );
        }
        
        // FIXED: Enhanced Transaction Modal with Smart Split Logic
        function TransactionModal({ user, people, editItem, onClose, theme, mutate, setData, data, fetchData, lastFetchParams, setDialog }) {
            const [tab, setTab] = useState(editItem ? (['lent','borrowed','repayment_in','repayment_out'].includes(editItem.type)?'friend':'simple') : 'simple');
            const [splitMode, setSplitMode] = useState('equal');
            const [includeMe, setIncludeMe] = useState(true);
            const [selectedFriends, setSelectedFriends] = useState([]);
            const [splitAmounts, setSplitAmounts] = useState({});
            const [lockedAmounts, setLockedAmounts] = useState({});
            const [form, setForm] = useState(editItem ? { 
                ...editItem, 
                date: editItem.date ? editItem.date.split('T')[0] : new Date().toISOString().split('T')[0], 
                totalBill: editItem.totalBill || '',
                amount: editItem.amount || '',
                category: editItem.category || 'General'
            } : { 
                type: 'expense', 
                amount: '', 
                category: 'General', 
                description: '', 
                date: new Date().toISOString().split('T')[0], 
                relatedPerson: '', 
                paymentMode: 'Online', 
                totalBill: '' 
            });
            const [loading, setLoading] = useState(false);
            // Reminder UI state (non-destructive, persists locally)
            const [reminderSent, setReminderSent] = useState(() => (editItem && editItem.id) ? (localStorage.getItem(`fm_reminder_${editItem.id}`) === '1') : false);
            const [sendingReminder, setSendingReminder] = useState(false);
            const [reminderToast, setReminderToast] = useState(null);

            const showReminderToast = (title, sub) => {
                setReminderToast({ title, sub });
                setTimeout(() => setReminderToast(null), 3000);
            };

            const doSendReminder = async () => {
                if (!editItem || !editItem.id) return;
                // Safety: if transaction is no longer pending, show completed dialog and abort
                if (editItem.status !== 'Pending') {
                    setDialog({ isOpen: true, title: 'Payment already completed', msg: 'This payment has been settled and no reminder is needed.', single: true, confirmLabel: 'OK' });
                    return;
                }
                setSendingReminder(true);
                try {
                    const recipient = people.find(p => p.id === (editItem.relatedPerson || form.relatedPerson));
                    const name = recipient?.name || '';
                    const recipientEmail = recipient?.email || null;
                    const amountText = formatMoney(form.amount || editItem.amount || 0);
                    const message = `Payment reminder\nHi, this is a reminder that a payment of ${amountText} to ${name} is still pending.\nPlease complete it when convenient.`;
                    if (mutate) {
                        try { await mutate({ action: 'sendReminder', transactionId: editItem.id, userId: user.id, notifyOnly: true, message, recipientEmail }); } catch(e) { /* ignore */ }
                    } else {
                        try { await fetch(API_URL, { method: 'POST', body: JSON.stringify({ action: 'sendReminder', transactionId: editItem.id, notifyOnly: true, message, recipientEmail }) }); } catch(e) { /* ignore */ }
                    }
                    localStorage.setItem(`fm_reminder_${editItem.id}`, '1');
                    setReminderSent(true);
                    showReminderToast('Reminder sent', "Theyâ€™ve been notified about the pending payment.");
                } finally {
                    setSendingReminder(false);
                }
            };
            
            const totalBillCents = toCents(form.totalBill || 0);
            const sumSplitsCents = Object.values(splitAmounts).reduce((sum, val) => sum + toCents(val || 0), 0);
            const remainingCents = totalBillCents - sumSplitsCents;
            const [splitError, setSplitError] = useState(null);
            const isSplitValid = !splitError && (sumSplitsCents === totalBillCents);
            
            // Compute split allocation given manual/locked entries and participants.
            const computeSplitAllocation = (totalCents, participants, splits, locks) => {
                const manualCents = {};
                participants.forEach(id => {
                    if (locks[id]) {
                        const v = splits[id] || 0;
                        manualCents[id] = toCents(v || 0);
                    }
                });
                for (const v of Object.values(manualCents)) {
                    if (v < 0) return { error: 'Negative amounts are not allowed' };
                }
                const manualSum = Object.values(manualCents).reduce((s, v) => s + v, 0);
                if (manualSum > totalCents) return { error: `Manual amounts exceed total by ${formatMoney(fromCents(manualSum - totalCents))}` };
                const remaining = totalCents - manualSum;
                const remainingParticipants = participants.filter(id => !locks[id]);
                if (remainingParticipants.length === 0) {
                    if (remaining === 0) {
                        const out = {};
                        participants.forEach(id => { out[id] = manualCents[id] || 0; });
                        return { splitsCents: out };
                    } else {
                        return { error: 'No participants left to allocate remaining amount' };
                    }
                }
                const share = Math.floor(remaining / remainingParticipants.length);
                const remainder = remaining - share * remainingParticipants.length;
                const out = {};
                participants.forEach(id => {
                    if (manualCents[id] !== undefined) {
                        out[id] = manualCents[id];
                    } else {
                        const isLast = id === remainingParticipants[remainingParticipants.length - 1];
                        out[id] = share + (isLast ? remainder : 0);
                    }
                });
                const sum = Object.values(out).reduce((s, v) => s + v, 0);
                if (sum !== totalCents) return { error: 'Internal split mismatch' };
                for (const v of Object.values(out)) if (v < 0) return { error: 'Negative allocations detected' };
                return { splitsCents: out };
            };

            useEffect(() => {
                if (tab !== 'split') return;
                const participantList = [...selectedFriends];
                if (includeMe) participantList.unshift('me'); // me first so remainder goes to last participant
                if (participantList.length === 0) {
                    setSplitAmounts({});
                    setSplitError(null);
                    return;
                }

                // If there are no locked/manual entries, perform equal split using cents to avoid drift.
                const { splitsCents, error } = (() => {
                    if (totalBillCents === 0) return { splitsCents: {} };
                    const hasLocked = Object.keys(lockedAmounts).some(k => lockedAmounts[k]);
                    if (!hasLocked) {
                        const count = participantList.length;
                        const share = Math.floor(totalBillCents / count);
                        const remainder = totalBillCents - share * count;
                        const out = {};
                        participantList.forEach((id, idx) => {
                            out[id] = share + (idx === (participantList.length - 1) ? remainder : 0);
                        });
                        return { splitsCents: out };
                    }
                    // Otherwise use manual locks and redistribute remaining
                    return computeSplitAllocation(totalBillCents, participantList, splitAmounts, lockedAmounts);
                })();

                if (error) {
                    setSplitError(error);
                    return;
                } else {
                    setSplitError(null);
                }

                // Convert cents to decimal amounts for display
                const newSplits = {};
                Object.entries(splitsCents || {}).forEach(([id, cents]) => {
                    newSplits[id] = fromCents(cents);
                });

                setSplitAmounts(newSplits);

            }, [form.totalBill, selectedFriends, includeMe, splitMode, tab, totalBillCents, splitAmounts, lockedAmounts]);

            // When user edits a participant amount manually, lock it and validate immediately.
            const handleCustomSplitChange = (id, value) => {
                const parsed = parseFloat(value);
                if (isNaN(parsed) || parsed < 0) {
                    setSplitError('Enter a valid non-negative amount');
                    setSplitAmounts(prev => ({ ...prev, [id]: value }));
                    setLockedAmounts(prev => ({ ...prev, [id]: true }));
                    return;
                }
                // Lock the participant to prevent auto-overwrite
                setLockedAmounts(prev => ({ ...prev, [id]: true }));
                setSplitAmounts(prev => ({ ...prev, [id]: parsed }));
                setSplitError(null);
            };

            // Toggle lock state for a participant (icon button)
            const toggleLockAmount = (id) => {
                setLockedAmounts(prev => {
                    const next = { ...prev };
                    if (next[id]) delete next[id];
                    else next[id] = true;
                    return next;
                });
            };
            
            const toggleFriend = (id) => {
                if (selectedFriends.includes(id)) {
                    setSelectedFriends(prev => prev.filter(f => f !== id));
                    const newSplits = { ...splitAmounts };
                    const newLocked = { ...lockedAmounts };
                    delete newSplits[id];
                    delete newLocked[id];
                    setSplitAmounts(newSplits);
                    setLockedAmounts(newLocked);
                } else {
                    setSelectedFriends(prev => [...prev, id]);
                }
            };
           
            const handleImage = (e) => { const file = e.target.files[0]; if(file) compressImage(file).then(b64 => setForm({...form, imageBase64: b64})); };
           
            const submit = async (e) => {
                e.preventDefault();
                setLoading(true);
                
                // VALIDATION: Check required fields
                if (tab === 'simple') {
                    if (!form.amount || parseFloat(form.amount) <= 0) {
                        alert('Please enter a valid amount greater than 0');
                        setLoading(false);
                        return;
                    }
                    if (!form.category || form.category.trim() === '') {
                        alert('Please enter a category');
                        setLoading(false);
                        return;
                    }
                    if (!form.date) {
                        alert('Please select a date');
                        setLoading(false);
                        return;
                    }
                }
                
                if (tab === 'friend') {
                    if (!form.amount || parseFloat(form.amount) <= 0) {
                        alert('Please enter a valid amount greater than 0');
                        setLoading(false);
                        return;
                    }
                    if (!form.relatedPerson) {
                        alert('Please select a friend');
                        setLoading(false);
                        return;
                    }
                    if (!form.category || form.category.trim() === '') {
                        alert('Please enter a category');
                        setLoading(false);
                        return;
                    }
                    if (!form.date) {
                        alert('Please select a date');
                        setLoading(false);
                        return;
                    }
                }
                
                // FINANCIAL CORRECTNESS: Validate split sum equals total
                if (tab === 'split') {
                    if (!form.totalBill || parseFloat(form.totalBill) <= 0) {
                        alert('Please enter a valid total bill amount');
                        setLoading(false);
                        return;
                    }
                    if (selectedFriends.length === 0 && !includeMe) {
                        alert('Please select at least one participant');
                        setLoading(false);
                        return;
                    }
                    if (!isSplitValid) {
                        if (splitError) alert(splitError);
                        else alert(`Split total (${formatMoney(fromCents(sumSplitsCents))}) does not match bill amount (${formatMoney(fromCents(totalBillCents))}). Difference: ${formatMoney(fromCents(remainingCents))}`);
                        setLoading(false);
                        return;
                    }
                    if (!form.category || form.category.trim() === '') {
                        alert('Please enter a category');
                        setLoading(false);
                        return;
                    }
                    if (!form.date) {
                        alert('Please select a date');
                        setLoading(false);
                        return;
                    }
                }
                
                let body = {};
                const isUpdate = editItem && editItem.id;
               
                if(tab === 'split') {
                    const items = [];
                   
                    // Create Payer Share (Confirmed Expense)
                    if(includeMe && splitAmounts['me'] && parseFloat(splitAmounts['me']) > 0) {
                        items.push({
                            ...form,
                            type: 'expense',
                            amount: parseFloat(splitAmounts['me']),
                            description: `${form.description || 'Split Bill'} (My Share)`,
                            relatedPerson: '',
                            status: 'Confirmed', // Payer's share is immediately confirmed
                            paymentMode: form.paymentMode || 'Online',
                            date: form.date,
                            category: form.category || 'General'
                        });
                    }
                   
                    // Create Friend Shares (Friends owe me money - they borrowed from me)
                    selectedFriends.forEach(id => {
                        const splitAmt = splitAmounts[id];
                        if(splitAmt && parseFloat(splitAmt) > 0) {
                            const friend = people.find(p => p.id === id);
                            const statusForFriend = (friend && friend.email) ? 'Pending' : 'Confirmed'; // auto-confirm for manual friends (no email)
                            items.push({
                                ...form,
                                type: 'borrowed', // Friend borrowed from me
                                amount: parseFloat(splitAmt),
                                description: `${form.description || 'Split Bill'} (Split Bill with ${friend?.name || 'Friend'})`,
                                relatedPerson: id,
                                status: statusForFriend,
                                paymentMode: form.paymentMode || 'Online',
                                date: form.date,
                                category: form.category || 'General'
                            });
                        }
                    });
                   
                    if(items.length === 0) { 
                        alert("Invalid split: No valid amounts to split"); 
                        setLoading(false); 
                        return; 
                    }
                    body = { action: 'batchAdd', userId: user.id, items };
                } else {
                    // FINANCIAL CORRECTNESS: Set appropriate status based on transaction type
                    let status = 'Confirmed';
                    if (['lent', 'borrowed', 'repayment_in', 'repayment_out'].includes(form.type) && form.relatedPerson) {
                        const target = people.find(p => p.id === form.relatedPerson);
                        status = (target && target.email) ? 'Pending' : 'Confirmed'; // auto-confirm if friend is manual/unlinked
                    }
                    
                    // Validate amount is valid number
                    const amountValue = parseFloat(form.amount);
                    if (isNaN(amountValue) || amountValue <= 0) {
                        alert('Please enter a valid amount greater than 0');
                        setLoading(false);
                        return;
                    }
                    
                    body = { 
                        action: isUpdate ? 'update' : 'add', 
                        id: isUpdate ? editItem.id : undefined, 
                        userId: user.id, 
                        ...form,
                        amount: amountValue,
                        status: isUpdate ? (editItem.status || status) : status
                    };
                }
               
                try {
                    if (mutate) {
                        // Optimistic update for add/update
                        if (body.action === 'add') {
                            const tmpId = 'tmp_' + Date.now();
                            const tmpItem = { ...form, id: tmpId, userId: user.id, status: body.status || 'Confirmed', amount: body.amount };
                            // insert at top
                            setData(prev => ({ ...prev, transactions: [tmpItem, ...(prev.transactions || [])] }));
                            onClose();
                            try {
                                const json = await mutate(body, { skipFetch: true });
                                if (json && json.success === false) {
                                    // remove tmp
                                    setData(prev => ({ ...prev, transactions: (prev.transactions || []).filter(tr => tr.id !== tmpId) }));
                                    alert(json.error || 'Error saving transaction');
                                    setLoading(false);
                                } else {
                                    // optionally refresh in background
                                    if (fetchData && lastFetchParams !== undefined) {
                                        fetchData(lastFetchParams);
                                    }
                                    setLoading(false);
                                }
                            } catch (e) {
                                setData(prev => ({ ...prev, transactions: (prev.transactions || []).filter(tr => tr.id !== tmpId) }));
                                alert('Error saving transaction: ' + (e.message || 'Network error'));
                                setLoading(false);
                            }
                            return;
                        }
                        if (body.action === 'update') {
                            // optimistic update local item
                            const prevItem = (data && data.transactions) ? data.transactions.find(x => x.id === body.id) : null;
                            setData(prev => ({ 
                                ...prev, 
                                transactions: (prev.transactions || []).map(tr => tr.id === body.id ? { ...tr, ...body, amount: body.amount } : tr) 
                            }));
                            onClose();
                            try {
                                const json = await mutate(body, { skipFetch: true });
                                if (json && json.success === false) {
                                    // rollback
                                    if (prevItem) {
                                        setData(prev => ({ ...prev, transactions: (prev.transactions || []).map(tr => tr.id === body.id ? prevItem : tr) }));
                                    }
                                    alert(json.error || 'Error updating transaction');
                                    setLoading(false);
                                } else {
                                    if (fetchData && lastFetchParams !== undefined) {
                                        fetchData(lastFetchParams);
                                    }
                                    setLoading(false);
                                }
                            } catch (e) {
                                if (prevItem) {
                                    setData(prev => ({ ...prev, transactions: (prev.transactions || []).map(tr => tr.id === body.id ? prevItem : tr) }));
                                }
                                alert('Error updating transaction: ' + (e.message || 'Network error'));
                                setLoading(false);
                            }
                            return;
                        }

                        // Fallback: default mutate behavior (for batchAdd)
                        const json = await mutate(body);
                        if (json && json.success === false) { 
                            alert(json.error || 'Error saving transaction'); 
                            setLoading(false); 
                            return; 
                        }
                        onClose();
                        setLoading(false);
                    } else {
                        const res = await fetch(API_URL, { method: 'POST', body: JSON.stringify(body) });
                        const json = await res.json();
                        if (json && json.success === false) {
                            alert(json.error || 'Error saving transaction');
                            setLoading(false);
                            return;
                        }
                        onClose();
                        setLoading(false);
                    }
                } catch (error) {
                    console.error('Transaction save error:', error);
                    alert("Error saving transaction: " + (error.message || 'Please check your connection and try again'));
                    setLoading(false);
                }
            };
           
            const handleDelete = async () => { 
                if(!confirm("Delete this transaction? This will revert all financial effects.")) return; 
                // Optimistic local delete
                const backup = (data && data.transactions) ? [...data.transactions] : [];
                setData(prev => ({ ...prev, transactions: prev.transactions.filter(tr => tr.id !== editItem.id) }));
                onClose();
                try {
                    if (mutate) {
                        const json = await mutate({ action: 'delete', id: editItem.id, userId: user.id, revertBalances: true }, { skipFetch: true });
                        if (json && json.success === false) {
                            // rollback
                            setData(prev => ({ ...prev, transactions: backup }));
                            alert(json.error || 'Error deleting transaction');
                        } else {
                            fetchData(lastFetchParams);
                        }
                    } else {
                        await fetch(API_URL, { method: 'POST', body: JSON.stringify({ action: 'delete', id: editItem.id, userId: user.id, revertBalances: true }) });
                        fetchData(lastFetchParams);
                    }
                } catch (e) {
                    setData(prev => ({ ...prev, transactions: backup }));
                    alert('Error');
                }
            };
            
            // FIXED: Render split validation status
            const renderSplitValidation = () => {
                if (tab !== 'split') return null;

                if (splitError) {
                    return (
                        <div className="text-xs font-bold text-center p-2 rounded-lg bg-red-50 text-red-600">
                            {splitError}
                        </div>
                    );
                }

                const isValid = sumSplitsCents === totalBillCents;
                return (
                    <div className={`text-xs font-bold text-center p-2 rounded-lg ${isValid ? 'bg-emerald-50 text-emerald-600' : 'bg-red-50 text-red-600'}`}>
                        {isValid ? (
                            'âœ“ Split amounts match total bill'
                        ) : (
                            `âš ï¸ Difference: ${formatMoney(fromCents(Math.abs(remainingCents)))} ${remainingCents > 0 ? 'remaining' : 'over'}`
                        )}
                    </div>
                );
            };
            
            // FIXED: Load example for your scenario
            const loadExample = () => {
                setForm({...form, totalBill: '500'});
                setIncludeMe(false);
                // Select first 3 friends for example
                const exampleFriends = people.slice(0, 3).map(p => p.id);
                setSelectedFriends(exampleFriends);
                
                setTimeout(() => {
                    setSplitAmounts({
                        [exampleFriends[0]]: 50,
                        [exampleFriends[1]]: 225,
                        [exampleFriends[2]]: 225
                    });
                    setLockedAmounts({
                        [exampleFriends[0]]: true // Lock Friend A's amount
                    });
                }, 100);
            };
            
            // FIXED: Common categories with auto-suggest
            const commonCategories = [
                'Food', 'Transport', 'Housing', 'Utilities', 'Entertainment', 
                'Shopping', 'Healthcare', 'Education', 'Personal Care', 'Gifts',
                'Investment', 'Income', 'General'
            ];
            
            return (
                <div className="fixed inset-0 z-50 flex items-end justify-center bg-slate-900/60 backdrop-blur-sm p-2 sm:items-center">
                    <div className="bg-white dark:bg-slate-900 w-full max-w-md modal-inner shadow-2xl animate-up max-h-[90vh] overflow-y-auto">
                        <div className="flex justify-between items-center mb-6">
                            <h3 className="font-bold text-xl dark:text-white">{editItem && editItem.id ? 'Edit Entry' : 'New Entry'}</h3>
                            <button onClick={onClose}><i data-lucide="x" className="w-5 h-5 text-slate-400"></i></button>
                        </div>
                        {!editItem && (
                            <div className="flex p-1 bg-slate-100 dark:bg-slate-800 rounded-2xl mb-6">
                                {['simple', 'friend', 'split'].map(t => (
                                    <button key={t} onClick={()=>setTab(t)} className={`flex-1 py-3 text-xs font-bold uppercase tracking-wider rounded-xl transition-all ${tab===t?'bg-white dark:bg-slate-700 shadow ' + THEMES[theme].text :'text-slate-400'}`}>
                                        {t}
                                    </button>
                                ))}
                            </div>
                        )}
                        <form onSubmit={submit} className="space-y-5">
                            {tab === 'simple' && (
                                <>
                                    <div className="flex gap-3">
                                        <button type="button" onClick={()=>setForm({...form, type:'income'})} className={`flex-1 py-4 rounded-2xl border-2 font-bold transition-all ${form.type==='income'?'border-emerald-500 bg-emerald-50 text-emerald-600 dark:bg-emerald-900/20':'border-transparent bg-slate-50 dark:bg-slate-800 text-slate-500'}`}>
                                            Money In
                                        </button>
                                        <button type="button" onClick={()=>setForm({...form, type:'expense'})} className={`flex-1 py-4 rounded-2xl border-2 font-bold transition-all ${form.type==='expense'?'border-red-500 bg-red-50 text-red-600 dark:bg-red-900/20':'border-transparent bg-slate-50 dark:bg-slate-800 text-slate-500'}`}>
                                            Money Out
                                        </button>
                                    </div>
                                    <div className={`bg-slate-50 dark:bg-slate-800 p-4 rounded-2xl border ${THEMES[theme].border} border-opacity-20`}>
                                        <p className={`text-xs font-bold uppercase ${THEMES[theme].text} mb-2`}>Amount</p>
                                        <input 
                                            type="number" 
                                            min="0" 
                                            step="0.01" 
                                            placeholder="â‚¹0.00" 
                                            className={`w-full bg-transparent text-2xl font-bold outline-none ${THEMES[theme].text}`} 
                                            value={form.amount || ''} 
                                            onChange={e => setForm({...form, amount: e.target.value})} 
                                            required 
                                        />
                                    </div>
                                </>
                            )}
                            {tab === 'split' && (
                                <div className="space-y-4">
                                    <div className={`bg-slate-50 dark:bg-slate-800 p-4 rounded-2xl border ${THEMES[theme].border} border-opacity-20`}>
                                        <div className="flex justify-between items-center mb-2">
                                            <p className={`text-xs font-bold uppercase ${THEMES[theme].text}`}>Total Bill</p>
                                            <button type="button" onClick={loadExample} className="text-xs text-slate-500 hover:text-indigo-500">
                                                Load Example
                                            </button>
                                        </div>
                                        <input type="number" min="0" step="0.01" placeholder="â‚¹0" className={`w-full bg-transparent text-3xl font-bold outline-none ${THEMES[theme].text}`} value={form.totalBill} onChange={e => setForm({...form, totalBill: e.target.value})} />
                                    </div>
                                    
                                    {renderSplitValidation()}
                                    
                                    <div className="flex gap-2 mb-2">
                                        <button type="button" onClick={()=>setSplitMode('equal')} className={`flex-1 py-2 text-xs font-bold rounded-lg border ${splitMode==='equal'?THEMES[theme].border + ' ' + THEMES[theme].text :'border-slate-200 text-slate-400'}`}>
                                            Smart Split
                                        </button>
                                        <button type="button" onClick={()=>setSplitMode('custom')} className={`flex-1 py-2 text-xs font-bold rounded-lg border ${splitMode==='custom'?THEMES[theme].border + ' ' + THEMES[theme].text :'border-slate-200 text-slate-400'}`}>
                                            Custom Split
                                        </button>
                                    </div>
                                    
<div className="flex items-center gap-3 p-3 bg-slate-50 dark:bg-slate-800 rounded-xl">
    <div className={`w-5 h-5 rounded border flex items-center justify-center cursor-pointer ${includeMe ? THEMES[theme].class + ' border-transparent text-white' : 'border-slate-300'}`} onClick={()=>setIncludeMe(!includeMe)}>
        {includeMe && <i data-lucide="check" className="w-3 h-3"></i>}
    </div>
    <div className="flex-1 text-sm font-bold dark:text-white">Include Me (Payer)</div>
    {includeMe && (
        <div className="flex items-center gap-2">
            <button type="button" onClick={() => toggleLockAmount('me')} className={`p-1 rounded ${lockedAmounts['me'] ? 'bg-indigo-100 text-indigo-600' : 'text-slate-400'}`}>
                <i data-lucide={lockedAmounts['me'] ? "lock" : "unlock"} className="w-3 h-3"></i>
            </button>
            <input type="number" min="0" step="0.01" className="w-20 p-2 text-right bg-transparent outline-none font-bold" placeholder="0" value={splitAmounts['me'] || ''} onChange={e => handleCustomSplitChange('me', e.target.value)} />
        </div>
    )}
</div>
                                <div className="space-y-2 max-h-40 overflow-y-auto hide-scroll">
                                    {people.map(p => (
                                        <div key={p.id} className={`flex items-center gap-3 p-3 rounded-xl border transition-all ${selectedFriends.includes(p.id) ? THEMES[theme].border + ' bg-slate-50 dark:bg-slate-800' : 'border-slate-200 dark:border-slate-800'}`}>
                                            <div onClick={()=>toggleFriend(p.id)} className="cursor-pointer">
                                                <Avatar imageId={p.imageId} name={p.name} size="sm" theme={theme} />
                                            </div>
                                            <div className="flex-1 text-sm font-bold dark:text-white cursor-pointer" onClick={()=>toggleFriend(p.id)}>
                                                {p.name}
                                                {!p.email && <span className="text-[10px] text-slate-500 ml-1">(Manual)</span>}
                                            </div>
                                            {selectedFriends.includes(p.id) && (
                                                <div className="flex items-center gap-2">
                                                    <button type="button" onClick={() => toggleLockAmount(p.id)} className={`p-1 rounded ${lockedAmounts[p.id] ? 'bg-indigo-100 text-indigo-600' : 'text-slate-400'}`}>
                                                        <i data-lucide={lockedAmounts[p.id] ? "lock" : "unlock"} className="w-3 h-3"></i>
                                                    </button>
                                                    <input type="number" min="0" step="0.01" className="w-20 p-2 text-right bg-transparent outline-none font-bold" placeholder="0" value={splitAmounts[p.id] || ''} onChange={e => handleCustomSplitChange(p.id, e.target.value)} />
                                                </div>
                                            )}
                                        </div>
                                    ))}
                                </div>
                                
                                {/* Split summary */}
                                <div className="bg-slate-50 dark:bg-slate-800 p-3 rounded-xl">
                                    <div className="flex justify-between text-xs font-bold mb-1">
                                        <span className="text-slate-500">Participants:</span>
                                        <span>{selectedFriends.length + (includeMe ? 1 : 0)}</span>
                                    </div>
                                    <div className="flex justify-between text-xs font-bold mb-1">
                                        <span className="text-slate-500">Total Bill:</span>
                                        <span className={THEMES[theme].text}>{formatMoney(form.totalBill || 0)}</span>
                                    </div>
                                    <div className="flex justify-between text-xs font-bold">
                                        <span className="text-slate-500">Split Total:</span>
                                        <span className={isSplitValid ? 'text-emerald-600' : 'text-red-600'}>
                                            {formatMoney(fromCents(sumSplitsCents))}
                                        </span>
                                    </div>
                                </div>
                            </div>
                        )}
                        {tab === 'friend' && (
                            <>
                                <select className="input-field" value={form.type} onChange={e=>setForm({...form, type:e.target.value})} required>
                                    <option value="lent">Money Rented (I gave)</option>
                                    <option value="borrowed">Money Taken (I took)</option>
                                    <option value="repayment_in">He Paid Back</option>
                                    <option value="repayment_out">I Paid Back</option>
                                </select>
                                <div className={`bg-slate-50 dark:bg-slate-800 p-4 rounded-2xl border ${THEMES[theme].border} border-opacity-20`}>
                                    <p className={`text-xs font-bold uppercase ${THEMES[theme].text} mb-2`}>Amount</p>
                                    <input 
                                        type="number" 
                                        min="0" 
                                        step="0.01" 
                                        placeholder="â‚¹0.00" 
                                        className={`w-full bg-transparent text-2xl font-bold outline-none ${THEMES[theme].text}`} 
                                        value={form.amount || ''} 
                                        onChange={e => setForm({...form, amount: e.target.value})} 
                                        required 
                                    />
                                </div>
                                <div className="flex gap-4 overflow-x-auto pb-2 hide-scroll">
                                    {people.length === 0 ? (
                                        <p className="text-sm text-slate-400 text-center w-full py-4">No friends added yet. Add a friend first.</p>
                                    ) : (
                                        people.map(p => (
                                            <div key={p.id} onClick={()=>setForm({...form, relatedPerson: p.id})} className="flex flex-col items-center gap-2 cursor-pointer group">
                                                <Avatar imageId={p.imageId} name={p.name} theme={theme} />
                                                <span className={`text-[10px] font-bold ${form.relatedPerson === p.id ? THEMES[theme].text :'text-slate-500'}`}>{p.name}</span>
                                                {!p.email && <span className="text-[8px] text-slate-400">Manual</span>}
                                            </div>
                                        ))
                                    )}
                                </div>
                                {form.type && ['lent', 'borrowed', 'repayment_in', 'repayment_out'].includes(form.type) && !form.relatedPerson && (
                                    <p className="text-xs text-amber-600 dark:text-amber-400 font-bold">âš ï¸ Please select a friend</p>
                                )}
                            </>
                        )}
                        <div className="flex gap-2">
                            <button type="button" onClick={()=>setForm({...form, paymentMode:'Online'})} className={`flex-1 py-3 rounded-xl text-xs font-bold transition-all ${form.paymentMode==='Online'?THEMES[theme].class + ' text-white shadow-lg':'bg-slate-100 dark:bg-slate-800 dark:text-slate-400'}`}>Online</button>
                            <button type="button" onClick={()=>setForm({...form, paymentMode:'Cash'})} className={`flex-1 py-3 rounded-xl text-xs font-bold transition-all ${form.paymentMode==='Cash'?THEMES[theme].class + ' text-white shadow-lg':'bg-slate-100 dark:bg-slate-800 dark:text-slate-400'}`}>Cash</button>
                        </div>

                        {/* Reminder action (UX): shown beneath payment status and amount, separated from financial actions */}
                        {editItem && editItem.id && editItem.status === 'Pending' && (
                            <div className="mt-4 p-3 rounded-xl border bg-slate-50 dark:bg-slate-800 border-slate-200 dark:border-slate-700">
                                <>
                                    <button type="button" onClick={() => {
                                        // confirmation popup per spec with explicit button label
                                        const recipient = people.find(p=>p.id === (editItem.relatedPerson || form.relatedPerson));
                                        const name = recipient?.name || 'them';
                                        setDialog({
                                            isOpen: true,
                                            title: 'Send reminder?',
                                            msg: `This will notify ${name} that the payment of ${formatMoney(form.amount || editItem.amount || 0)} is still pending.\nNo payment will be processed automatically.`,
                                            onConfirm: async () => { setDialog({ isOpen: false }); await doSendReminder(); },
                                            onCancel: () => setDialog({ isOpen: false }),
                                            type: 'neutral',
                                            confirmLabel: 'Send reminder'
                                        });
                                    }} className={`w-full py-3 rounded-xl font-bold text-sm ${reminderSent ? 'bg-slate-100 text-slate-500' : THEMES[theme].class + ' text-white shadow-lg'}`}>
                                        {sendingReminder ? 'Sending...' : (reminderSent ? 'Send reminder again' : 'Send payment reminder')}
                                    </button>
                                    <div className="mt-2 text-xs text-slate-400">{reminderSent ? "Reminder sent" : "Reminds the other person about this pending payment"}</div>
                                    {reminderToast && (
                                        <div className="mt-3 p-2 rounded-lg bg-emerald-50 text-emerald-700 text-sm font-bold">
                                            <div>{reminderToast.title}</div>
                                            <div className="text-xs font-normal">{reminderToast.sub}</div>
                                        </div>
                                    )}
                                </>
                            </div>
                        )}
                        
                        {/* FIXED: Category input with suggestions */}
                        <div className="relative">
                            <input 
                                className="input-field" 
                                placeholder="Category (e.g., Food, Transport)" 
                                value={form.category || ''} 
                                onChange={e=>setForm({...form, category:e.target.value})} 
                                list="category-suggestions"
                                required 
                            />
                            <datalist id="category-suggestions">
                                {commonCategories.map(cat => (
                                    <option key={cat} value={cat} />
                                ))}
                                {/* Add common sub-categories that will be normalized */}
                                <option value="Egg" />
                                <option value="Chicken" />
                                <option value="Fuel" />
                                <option value="Uber" />
                                <option value="Movie" />
                                <option value="Netflix" />
                                <option value="Rent" />
                                <option value="Electricity" />
                            </datalist>
                            {form.category && (
                                <div className="absolute right-3 top-1/2 transform -translate-y-1/2 pointer-events-none">
                                    <span className="text-xs text-slate-400 bg-white dark:bg-slate-900 px-1 rounded">
                                        â†’ {normalizeCategory(form.category)}
                                    </span>
                                </div>
                            )}
                        </div>
                        
                        <textarea 
                            className="input-field" 
                            placeholder="Description (Optional)" 
                            value={form.description || ''} 
                            onChange={e=>setForm({...form, description:e.target.value})} 
                            rows="2" 
                        />
                        <label className="flex items-center gap-3 p-3 rounded-xl border border-dashed border-slate-300 dark:border-slate-700 cursor-pointer hover:bg-slate-50 dark:hover:bg-slate-800">
                            <div className={`w-10 h-10 rounded-full flex items-center justify-center bg-slate-100 text-slate-400`}>
                                <i data-lucide={form.imageBase64 ? 'check' : 'camera'}></i>
                            </div>
                            <span className="text-sm text-slate-500">{form.imageBase64 ? 'Receipt Attached' : 'Attach Receipt'}</span>
                            <input type="file" className="hidden" accept="image/*" onChange={handleImage} />
                        </label>
                        <div>
                            <label className="block text-xs font-bold text-slate-500 uppercase mb-2">Date</label>
                            <input 
                                className="input-field" 
                                type="date" 
                                value={form.date || ''} 
                                onChange={e=>setForm({...form, date:e.target.value})} 
                                required 
                                max={new Date().toISOString().split('T')[0]}
                            />
                        </div>
                        <button 
                            disabled={loading || (tab === 'split' && !isSplitValid)} 
                            className={`btn-primary shadow-xl text-lg ${THEMES[theme].class} ${(loading || (tab === 'split' && !isSplitValid)) ? 'opacity-50 cursor-not-allowed' : ''}`}
                        >
                            {loading ? 'Saving...' : (editItem && editItem.id ? 'Update' : 'Save')}
                        </button>
                        {editItem && editItem.id && (
                            <button type="button" onClick={handleDelete} className="w-full py-3 text-red-500 font-bold bg-red-50 dark:bg-red-900/20 rounded-xl">
                                Delete Entry
                            </button>
                        )}
                    </form>
                </div>
            </div>
        );
    }
    
    function PersonModal({ user, onClose, theme, mutate }) { 
        const [mode, setMode] = useState('search'); 
        const [query, setQuery] = useState(''); 
        const [results, setResults] = useState([]); 
        const [loading, setLoading] = useState(false); 
        const [manualForm, setManualForm] = useState({ name: '', phone: '', imageBase64: '' }); 
        
        const handleSearch = async (e) => { 
            e.preventDefault(); 
            setLoading(true); 
            try { 
                const res = await fetch(`${API_URL}?action=searchUsers&userId=${user.id}&query=${query}`); 
                const json = await res.json(); 
                if(json.success) setResults(json.results); 
            } catch(e) {} 
            setLoading(false); 
        }; 
        
        const connectUser = async (targetUser) => { 
            setLoading(true); 
            try {
                if (mutate) {
                    const json = await mutate({ action: 'addPerson', userId: user.id, linkedUserId: targetUser.id, name: targetUser.name });
                    if (json && json.success === false) { alert(json.error || 'Error'); }
                    else onClose();
                } else {
                    await fetch(API_URL, { method: 'POST', body: JSON.stringify({ action: 'addPerson', userId: user.id, linkedUserId: targetUser.id, name: targetUser.name }) });
                    onClose();
                }
            } catch (e) { alert('Error'); } finally { setLoading(false); }
        };
        
        const handleImage = (e) => { 
            const file = e.target.files[0]; 
            if(file) compressImage(file).then(b64 => setManualForm({...manualForm, imageBase64: b64})); 
        }; 
        
        const submitManual = async (e) => { 
            e.preventDefault(); 
            setLoading(true); 
            try {
                if (mutate) {
                    const json = await mutate({ action: 'addPerson', userId: user.id, ...manualForm });
                    if (json && json.success === false) { alert(json.error || 'Error'); }
                    else onClose();
                } else {
                    await fetch(API_URL, { method: 'POST', body: JSON.stringify({ action: 'addPerson', userId: user.id, ...manualForm }) });
                    onClose();
                }
            } catch(e) { alert('Error'); } finally { setLoading(false); }
        }; 
        
        return (
            <div className="fixed inset-0 z-50 flex items-center justify-center bg-slate-900/60 backdrop-blur-sm p-4">
                <div className="bg-white dark:bg-slate-900 w-full max-w-sm rounded-[2rem] p-6 animate-up shadow-2xl h-[500px] flex flex-col">
                    <div className="flex justify-between items-center mb-4">
                        <h3 className="font-bold text-lg dark:text-white">{mode==='search'?'Find Friend':'Add Manual Reminder'}</h3>
                        <button onClick={onClose}><i data-lucide="x" className="w-5 h-5 text-slate-400"></i></button>
                    </div>
                    {mode === 'search' ? (
                        <div className="flex-1 flex flex-col">
                            <form onSubmit={handleSearch} className="flex gap-2 mb-4">
                                <input className="input-field py-2" placeholder="Search by name..." value={query} onChange={e=>setQuery(e.target.value)} autoFocus />
                                <button className={`text-white p-3 rounded-xl ${THEMES[theme].class}`}><i data-lucide="search" className="w-5 h-5"></i></button>
                            </form>
                            <div className="flex-1 overflow-y-auto space-y-2 mb-4">
                                {results.map(r => (
                                    <div key={r.id} className="flex items-center justify-between p-3 bg-slate-50 dark:bg-slate-800 rounded-xl">
                                        <div className="flex items-center gap-3">
                                            <Avatar imageId={r.imageId} name={r.name} size="sm" theme={theme} />
                                            <span className="font-bold text-sm dark:text-white">{r.name}</span>
                                        </div>
                                        <button onClick={()=>connectUser(r)} disabled={loading} className={`text-xs px-3 py-1.5 rounded-lg font-bold bg-slate-100 ${THEMES[theme].text}`}>Connect</button>
                                    </div>
                                ))}
                            </div>
                            <div className="text-center pt-4 border-t border-slate-100 dark:border-slate-800">
                                <p className="text-xs text-slate-400 mb-2">Can't find them?</p>
                                <button onClick={()=>setMode('manual')} className="w-full py-3 bg-slate-100 dark:bg-slate-800 text-slate-600 dark:text-slate-300 font-bold rounded-xl text-sm">Add Manually (No Sync)</button>
                            </div>
                        </div>
                    ) : (
                        <form onSubmit={submitManual} className="flex-1 flex flex-col gap-4">
                            <label className="block w-20 h-20 mx-auto rounded-full bg-slate-100 dark:bg-slate-800 border-2 border-dashed border-slate-300 flex items-center justify-center overflow-hidden cursor-pointer hover:bg-slate-200 transition">
                                {manualForm.imageBase64 ? <img src={manualForm.imageBase64} className="w-full h-full object-cover"/> : <i data-lucide="camera" className="text-slate-400 w-6 h-6"></i>}
                                <input type="file" className="hidden" accept="image/*" onChange={handleImage} />
                            </label>
                            <input className="input-field" placeholder="Name" value={manualForm.name} onChange={e=>setManualForm({...manualForm, name:e.target.value})} required />
                            <input className="input-field" placeholder="Phone (Optional)" value={manualForm.phone} onChange={e=>setManualForm({...manualForm, phone:e.target.value})} />
                            <div className="mt-auto flex gap-3">
                                <button type="button" onClick={()=>setMode('search')} className="flex-1 py-3 text-slate-500 font-bold">Back</button>
                                <button disabled={loading} className={`flex-1 btn-primary shadow-lg ${THEMES[theme].class}`}>{loading ? '...' : 'Save'}</button>
                            </div>
                        </form>
                    )}
                </div>
            </div>
        ); 
    }
    
    function ProfileView({ user, onUpdate, theme, setTheme, setAccentColor, mutate }) { 
        const [form, setForm] = useState({ username: user.name, phone: user.phone, imageBase64: '' }); 
        const [loading, setLoading] = useState(false); 
        
        const handleImage = (e) => { 
            const file = e.target.files[0]; 
            if(file) compressImage(file).then(b64 => setForm({...form, imageBase64: b64})); 
        }; 
        
        const save = async () => {
            setLoading(true);
            try {
                if (mutate) {
                    const json = await mutate({ action: 'updateProfile', userId: user.id, ...form });
                    if (json && json.success) {
                        const newUser = { ...user, name: form.username, phone: form.phone };
                        if (json.imageId) newUser.imageId = json.imageId;
                        onUpdate(newUser);
                        alert('Updated!');
                    } else {
                        alert(json?.error || 'Error');
                    }
                } else {
                    const res = await fetch(API_URL, { method: 'POST', body: JSON.stringify({ action: 'updateProfile', userId: user.id, ...form }) });
                    const json = await res.json();
                    if (json && json.success) {
                        const newUser = { ...user, name: form.username, phone: form.phone };
                        if (json.imageId) newUser.imageId = json.imageId;
                        onUpdate(newUser);
                        alert('Updated!');
                    } else {
                        alert(json?.error || 'Error');
                    }
                }
            } catch (e) { alert('Error'); }
            setLoading(false);
        };
        
        return (
            <div className="animate-fade space-y-8 p-2">
                <div className="flex flex-col items-center">
                    <label className="relative cursor-pointer group">
                        <Avatar imageId={user.imageId} name={user.name} size="lg" theme={theme} />
                        <div className={`absolute bottom-0 right-0 rounded-full p-1 text-white ${THEMES[theme].class}`}>
                            <i data-lucide="camera" className="w-4 h-4"></i>
                        </div>
                        <input type="file" className="hidden" accept="image/*" onChange={handleImage} />
                    </label>
                    <p className="mt-4 text-sm text-slate-400 font-bold">{user.email}</p>
                </div>
                <input className="input-field" value={form.username} onChange={e=>setForm({...form, username:e.target.value})} placeholder="Name" />
                <input className="input-field" value={form.phone} onChange={e=>setForm({...form, phone:e.target.value})} placeholder="Phone" />
                <button onClick={save} disabled={loading} className={`btn-primary shadow-lg ${THEMES[theme].class}`}>{loading?'...':'Update'}</button>
            </div>
        ); 
    }
    
    function Auth({ onLogin }) { 
        const [view, setView] = useState('login'); 
        const [form, setForm] = useState({ email: '', password: '', username: '', phone: '' }); 
        const [loading, setLoading] = useState(false); 
        const [msg, setMsg] = useState(null); 
        
        const submit = async (e) => { 
            e.preventDefault(); 
            setLoading(true); 
            setMsg(null); 
            try { 
                const url = view === 'login' ? `${API_URL}?action=login&email=${form.email}&password=${form.password}` : API_URL; 
                const opts = view === 'login' ? {} : { method: 'POST', body: JSON.stringify({ action: view, ...form }) }; 
                const res = await fetch(url, opts); 
                const json = await res.json(); 
                if(json.success) { 
                    if(view === 'login') onLogin(json.user); 
                    else { setMsg({type:'s', text:'Success! Login now.'}); setView('login'); } 
                } else setMsg({type:'e', text: json.error}); 
            } catch(e) { setMsg({type:'e', text: "Connection Error"}); } 
            setLoading(false); 
        }; 
        
        return (
            <div className="h-full flex items-center justify-center p-6 bg-slate-100 dark:bg-slate-900">
                <div className="w-full max-w-sm bg-white dark:bg-slate-950 p-8 rounded-[2rem] shadow-2xl animate-up">
                    <h1 className="text-3xl font-bold text-center mb-2">FinanceMax</h1>
                    {msg && <div className={`p-3 rounded-xl text-center text-sm mb-4 font-bold ${msg.type==='e'?'bg-red-50 text-red-500':'bg-emerald-50 text-emerald-600'}`}>{msg.text}</div>}
                    <form onSubmit={submit} className="space-y-4 mt-6">
                        {view==='signup' && (
                            <>
                                <input className="input-field" placeholder="Username" value={form.username} onChange={e=>setForm({...form, username:e.target.value})} required />
                                <input className="input-field" placeholder="Phone" value={form.phone} onChange={e=>setForm({...form, phone:e.target.value})} />
                            </>
                        )}
                        <input className="input-field" placeholder="Email" type="email" value={form.email} onChange={e=>setForm({...form, email:e.target.value})} required />
                        <input type="password" className="input-field" placeholder="Password" value={form.password} onChange={e=>setForm({...form, password:e.target.value})} required />
                        <button disabled={loading} className="btn-primary bg-indigo-600 shadow-xl shadow-indigo-500/30">
                            {loading ? <div className="loader mx-auto"></div> : (view==='login'?'Login':'Sign Up')}
                        </button>
                    </form>
                    <button onClick={()=>setView(view==='login'?'signup':'login')} className="w-full mt-6 text-sm text-slate-400 hover:text-indigo-500">
                        {view==='login'?'Create Account':'Back to Login'}
                    </button>
                </div>
            </div>
        ); 
    }
    
// Small responsive CSS helpers for modal and status icons
        const globalResponsiveStyles = `
            .modal-inner { border-radius: 1.25rem; padding: 1.25rem; }
            .confirm-buttons { display: flex; gap: .75rem; }
            .confirm-buttons.stack-on-mobile { display: flex; gap: .75rem; }
            @media (max-width: 520px) {
                .modal-inner { padding: .9rem; border-radius: 1rem; max-width: 94%; }
                .confirm-buttons.stack-on-mobile { flex-direction: column; }
            }
            .wrap-break { white-space: pre-wrap; word-break: break-word; }
            .status-icon-inline { display:inline-flex; width:1.5rem; height:1.5rem; min-width:1.5rem; align-items:center; justify-content:center; border-radius:9999px; }
            .status-icon-small { display:inline-flex; width:1rem; height:1rem; min-width:1rem; align-items:center; justify-content:center; border-radius:9999px; }

            /* Hide horizontal scrollbar visually but keep scrolling functional */
            .scroll-x { overflow-x: auto; overflow-y: hidden; -webkit-overflow-scrolling: touch; -ms-overflow-style: none; scrollbar-width: none; padding-bottom: 6px; }
            .scroll-x::-webkit-scrollbar { display: none; height: 0; }
            .scroll-x > * { display: inline-flex; }

            .theme-swatches { display:flex; gap:.5rem; align-items:center; }
            .swatch { box-sizing: border-box; flex-shrink:0; }
            .theme-row { gap: .75rem; }
            @media (max-width:520px) { .theme-swatches { gap:.5rem; } }
        `;
        if (!document.getElementById('fm-responsive-styles')) {
            const s = document.createElement('style');
            s.id = 'fm-responsive-styles';
            s.innerText = globalResponsiveStyles;
            document.head.appendChild(s);
        }

        function App() { 
        const [user, setUser] = useState(null); 
        useEffect(() => { 
            const saved = localStorage.getItem('fm_plat_user'); 
            if(saved) setUser(JSON.parse(saved)); 
        }, []); 
        
        const handleLogin = (u) => { 
            setUser(u); 
            localStorage.setItem('fm_plat_user', JSON.stringify(u)); 
        }; 
        
        const handleLogout = () => { 
            setUser(null); 
            localStorage.removeItem('fm_plat_user'); 
        }; 
        
        return user ? <Dashboard user={user} onLogout={handleLogout} /> : <Auth onLogin={handleLogin} />; 
    }
    
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>
</body>
</html>
